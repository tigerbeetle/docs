"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5511],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>k});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=p(n),u=i,k=m["".concat(s,".").concat(u)]||m[u]||h[u]||r;return n?a.createElement(k,l(l({ref:t},c),{},{components:n})):a.createElement(k,l({ref:t},c))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[m]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8e3:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:4},l="State Sync",o={unversionedId:"about/internals/sync",id:"about/internals/sync",title:"State Sync",description:"State sync synchronizes the state of a lagging replica with the healthy cluster.",source:"@site/pages/about/internals/sync.md",sourceDirName:"about/internals",slug:"/about/internals/sync",permalink:"/about/internals/sync",draft:!1,editUrl:"https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/about/internals/sync.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"LSM",permalink:"/about/internals/lsm"},next:{title:"Testing",permalink:"/about/internals/testing"}},s={},p=[{value:"Glossary",id:"glossary",level:2},{value:"Algorithm",id:"algorithm",level:2},{value:"0: Scenarios",id:"0-scenarios",level:3},{value:"1: Triggers",id:"1-triggers",level:3},{value:"Concepts",id:"concepts",level:2},{value:"Syncing Replica",id:"syncing-replica",level:3},{value:"Checkpoint Identifier",id:"checkpoint-identifier",level:3},{value:"Storage Determinism",id:"storage-determinism",level:3}],c={toc:p},m="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"state-sync"},"State Sync"),(0,i.kt)("p",null,"State sync synchronizes the state of a lagging replica with the healthy cluster."),(0,i.kt)("p",null,"State sync is used when a lagging replica's log no longer intersects with the cluster's current\nlog \u2014 ",(0,i.kt)("a",{parentName:"p",href:"/about/internals/vsr#protocol-repair-wal"},"WAL repair")," cannot catch the replica up."),(0,i.kt)("p",null,'(VRR refers to state sync as "state transfer", but we already have\n',(0,i.kt)("a",{parentName:"p",href:"/reference/transfer"},"transfers")," elsewhere.)"),(0,i.kt)("p",null,'In the context of state sync, "state" refers to:'),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"the superblock ",(0,i.kt)("inlineCode",{parentName:"li"},"vsr_state.checkpoint")),(0,i.kt)("li",{parentName:"ol"},"the grid (manifest, free set, and client sessions blocks)"),(0,i.kt)("li",{parentName:"ol"},"the grid (LSM table data; acquired blocks only)"),(0,i.kt)("li",{parentName:"ol"},"client replies")),(0,i.kt)("p",null,"State sync consists of four protocols:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/about/internals/vsr#protocol-requeststart-view"},"Sync Superblock")," (syncs 1)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/about/internals/vsr#protocol-repair-grid"},"Repair Grid")," (syncs 2)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/about/internals/vsr#protocol-sync-forest"},"Sync Forest")," (syncs 3)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/about/internals/vsr#protocol-sync-client-replies"},"Sync Client Replies")," (syncs 4)")),(0,i.kt)("p",null,"The target of superblock-sync is the latest checkpoint of the healthy cluster. When we catch up to\nthe latest checkpoint (or very close to it), then we can transition back to a healthy state."),(0,i.kt)("p",null,"State sync is lazy \u2014 logically, sync is completed when the superblock is synced. The data\npointed to by the new superblock can be transferred on-demand."),(0,i.kt)("p",null,"The state (superblock) and the WAL are updated atomically \u2014 ",(0,i.kt)("a",{parentName:"p",href:"/about/internals/vsr#start_view"},(0,i.kt)("inlineCode",{parentName:"a"},"start_view")),"\nmessage includes both."),(0,i.kt)("h2",{id:"glossary"},"Glossary"),(0,i.kt)("p",null,"Replica roles:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"syncing replica"),": A replica performing superblock-sync. (Any step within ",(0,i.kt)("em",{parentName:"li"},"1"),"-",(0,i.kt)("em",{parentName:"li"},"5")," of the\n",(0,i.kt)("a",{parentName:"li",href:"#algorithm"},"sync algorithm"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"healthy replica"),": A replica ",(0,i.kt)("em",{parentName:"li"},"not")," performing superblock-sync \u2014 part of the active cluster.")),(0,i.kt)("p",null,"Checkpoints:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#checkpoint-identifier"},(0,i.kt)("em",{parentName:"a"},"checkpoint id"),"/",(0,i.kt)("em",{parentName:"a"},"checkpoint identifier")),": Uniquely identifies a\nparticular checkpoint reproducibly across replicas. It is a hash over the entire state."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Durable checkpoint"),": A checkpoint whose state is present on at least replication quorum different\nreplicas.")),(0,i.kt)("h2",{id:"algorithm"},"Algorithm"),(0,i.kt)("ol",{start:0},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#0-scenarios"},"Sync is needed"),"."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#1-triggers"},"Trigger sync in response to ",(0,i.kt)("inlineCode",{parentName:"a"},"start_view")),"."),(0,i.kt)("li",{parentName:"ol"},"Interrupt the in-progress commit process:\n2.1. Wait for write operations to finish.\n2.2. Cancel potentially stalled read operations. (See ",(0,i.kt)("inlineCode",{parentName:"li"},"Grid.cancel()"),".)\n2.3. Wait for cancellation to finish."),(0,i.kt)("li",{parentName:"ol"},"Install the new checkpoint and matching headers into the superblock:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Bump ",(0,i.kt)("inlineCode",{parentName:"li"},"vsr_state.checkpoint.header")," to the sync target header."),(0,i.kt)("li",{parentName:"ul"},"Bump ",(0,i.kt)("inlineCode",{parentName:"li"},"vsr_state.checkpoint.parent_checkpoint_id")," to the checkpoint id that is previous to our\nsync target (i.e. it isn't ",(0,i.kt)("em",{parentName:"li"},"our")," previous checkpoint)."),(0,i.kt)("li",{parentName:"ul"},"Bump ",(0,i.kt)("inlineCode",{parentName:"li"},"replica.commit_min"),"."),(0,i.kt)("li",{parentName:"ul"},"Set ",(0,i.kt)("inlineCode",{parentName:"li"},"vsr_state.sync_op_min")," to the minimum op which has not been repaired."),(0,i.kt)("li",{parentName:"ul"},"Set ",(0,i.kt)("inlineCode",{parentName:"li"},"vsr_state.sync_op_max")," to the maximum op which has not been repaired."))),(0,i.kt)("li",{parentName:"ol"},"Repair ",(0,i.kt)("a",{parentName:"li",href:"/about/internals/vsr#protocol-sync-client-replies"},"replies"),",\n",(0,i.kt)("a",{parentName:"li",href:"/about/internals/vsr#protocol-repair-grid"},"free set, client sessions, and manifest blocks"),", and\n",(0,i.kt)("a",{parentName:"li",href:"/about/internals/vsr#protocol-sync-forest"},"table blocks")," that were created within the ",(0,i.kt)("inlineCode",{parentName:"li"},"sync_op_{min,max}"),"\nrange."),(0,i.kt)("li",{parentName:"ol"},"Update the superblock with:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Set ",(0,i.kt)("inlineCode",{parentName:"li"},"vsr_state.sync_op_min = 0")),(0,i.kt)("li",{parentName:"ul"},"Set ",(0,i.kt)("inlineCode",{parentName:"li"},"vsr_state.sync_op_max = 0"))))),(0,i.kt)("p",null,"If the replica starts up with ",(0,i.kt)("inlineCode",{parentName:"p"},"vsr_state.sync_op_max \u2260 0"),", go to step ",(0,i.kt)("em",{parentName:"p"},"4"),"."),(0,i.kt)("h3",{id:"0-scenarios"},"0: Scenarios"),(0,i.kt)("p",null,"Scenarios requiring state sync:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"A replica was down/partitioned/slow for a while and the rest of the cluster moved on. The lagging\nreplica is too far behind to catch up via WAL repair."),(0,i.kt)("li",{parentName:"ol"},"A replica was just formatted and is being added to the cluster (i.e. via\n",(0,i.kt)("a",{parentName:"li",href:"/about/internals/vsr#protocol-reconfiguration"},"reconfiguration"),"). The new replica is too far behind to catch\nup via WAL repair.")),(0,i.kt)("p",null,"Deciding between between WAL repair and state sync:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If a replica lags by more than one checkpoint behind the primary, it must use state sync."),(0,i.kt)("li",{parentName:"ul"},"If a replica is on the same checkpoint as the primary, it can only repair WAL."),(0,i.kt)("li",{parentName:"ul"},"If a replica is just one checkpoint behind, either WAL repair or state sync might be necessary:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"State sync is incorrect if there is only a single other replica on the next checkpoint --- the\nreplica that is ahead could have its state corrupted."),(0,i.kt)("li",{parentName:"ul"},"WAL repair is incorrect if all reachable peer replicas have already wrapped their logs and\nevicted some prepares from the preceding checkpoint."),(0,i.kt)("li",{parentName:"ul"},"Summarizing, if the next checkpoint is durable (replicated on a quorum of replicas), the\nlagging replica must eventually state sync.")))),(0,i.kt)("h3",{id:"1-triggers"},"1: Triggers"),(0,i.kt)("p",null,"State sync is triggered when a replica receives a ",(0,i.kt)("inlineCode",{parentName:"p"},"start_view")," message with a more advanced\ncheckpoint."),(0,i.kt)("p",null,"If a replica isn't making progress committing because a grid block or a prepare can't be repaired\nfor some time, the replica proactively sends ",(0,i.kt)("inlineCode",{parentName:"p"},"request_start_view")," to initiate the sync (see\n",(0,i.kt)("inlineCode",{parentName:"p"},"repair_sync_timeout"),")."),(0,i.kt)("h2",{id:"concepts"},"Concepts"),(0,i.kt)("h3",{id:"syncing-replica"},"Syncing Replica"),(0,i.kt)("p",null,"Syncing replicas participate in replication normally. They can append prepares, commit, and are\neligible to become primaries. In particular, a syncing replica can advance its own checkpoint as a\npart of the normal commit process."),(0,i.kt)("p",null,"The only restriction is that syncing replicas don't contribute to their checkpoint's replication\nquorum. That is, for the cluster as a whole to advance the checkpoint, there must be at least a\nreplication quorum of healthy replicas."),(0,i.kt)("p",null,"The mechanism for discovering sufficiently replicated (durable) checkpoints uses ",(0,i.kt)("inlineCode",{parentName:"p"},"prepare_ok"),"\nmessages. Sending a ",(0,i.kt)("inlineCode",{parentName:"p"},"prepare_ok")," signals that the replica has a recent checkpoint fully synced. As a\nconsequence, observing a ",(0,i.kt)("inlineCode",{parentName:"p"},"commit_max")," sufficiently ahead of a checkpoint signifies the durability of\nthe checkpoint."),(0,i.kt)("p",null,"For this reason, syncing replicas withhold ",(0,i.kt)("inlineCode",{parentName:"p"},"prepare_ok")," until ",(0,i.kt)("inlineCode",{parentName:"p"},"commit_max")," confirms that their\ncheckpoint is fully replicated on a quorum of different replicas. See ",(0,i.kt)("inlineCode",{parentName:"p"},"op_prepare_max"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"op_prepare_ok_max")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"op_repair_min")," for details."),(0,i.kt)("h3",{id:"checkpoint-identifier"},"Checkpoint Identifier"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"checkpoint id")," is a hash of the superblock ",(0,i.kt)("inlineCode",{parentName:"p"},"CheckpointState"),"."),(0,i.kt)("p",null,"A checkpoint identifier is attached to the following message types:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"command=commit"),": Current checkpoint identifier of sender."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"command=ping"),": Current checkpoint identifier of sender."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"command=prepare"),": The attached checkpoint id is the checkpoint id during which the corresponding\nprepare was originally prepared."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"command=prepare_ok"),": The attached checkpoint id is the checkpoint id during which the\ncorresponding prepare was originally prepared.")),(0,i.kt)("h3",{id:"storage-determinism"},"Storage Determinism"),(0,i.kt)("p",null,"When everything works, storage is deterministic. If non-determinism is detected (via checkpoint id\nmismatches) the replica which detects the mismatch will panic. This scenario should prompt operator\ninvestigation and manual intervention."))}h.isMDXComponent=!0}}]);