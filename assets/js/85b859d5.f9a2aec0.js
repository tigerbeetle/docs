"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6214],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),h=r,m=d["".concat(l,".").concat(h)]||d[h]||p[h]||i;return n?a.createElement(m,o(o({ref:t},u),{},{components:n})):a.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7796:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:5},o="Architecture",s={unversionedId:"about/architecture",id:"about/architecture",title:"Architecture",description:"In theory, TigerBeetle is a replicated state machine that takes an initial starting state",source:"@site/pages/about/architecture.md",sourceDirName:"about",slug:"/about/architecture",permalink:"/about/architecture",draft:!1,editUrl:"https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/about/architecture.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Performance",permalink:"/about/performance"},next:{title:"production-readiness",permalink:"/about/production-readiness"}},l={},c=[{value:"Data Structures",id:"data-structures",level:2},{value:"Events",id:"events",level:3},{value:"States",id:"states",level:3},{value:"Protocol",id:"protocol",level:2},{value:"Protocol Design Decisions",id:"protocol-design-decisions",level:3}],u={toc:c},d="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"architecture"},"Architecture"),(0,r.kt)("p",null,"In theory, TigerBeetle is a replicated state machine that ",(0,r.kt)("strong",{parentName:"p"},"takes an initial starting state"),"\n(account opening balances), and ",(0,r.kt)("strong",{parentName:"p"},"applies a set of input events")," (transfers) in deterministic\norder, after first replicating these input events safely, to ",(0,r.kt)("strong",{parentName:"p"},"arrive at a final state")," (account\nclosing balances)."),(0,r.kt)("p",null,"In practice, TigerBeetle is based on the ",(0,r.kt)("a",{parentName:"p",href:"https://www.infoq.com/presentations/LMAX/"},"LMAX Exchange\nArchitecture")," and makes a few improvements."),(0,r.kt)("p",null,"We take the same three classic LMAX steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"journal incoming events safely to disk, and replicate to backup nodes, then"),(0,r.kt)("li",{parentName:"ol"},"apply these events to the in-memory state, then"),(0,r.kt)("li",{parentName:"ol"},"ACK to the client")),(0,r.kt)("p",null,"And then we introduce something new:"),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},"delete the local journalling step entirely, and"),(0,r.kt)("li",{parentName:"ol"},"replace it with parallel replication to 3/5 distributed replicas.")),(0,r.kt)("p",null,"Our architecture then becomes three easy steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"replicate incoming events safely to a quorum of distributed replicas, then"),(0,r.kt)("li",{parentName:"ol"},"apply these events to the in-memory state, then"),(0,r.kt)("li",{parentName:"ol"},"ACK to the client")),(0,r.kt)("p",null,"That's how TigerBeetle ",(0,r.kt)("strong",{parentName:"p"},"eliminates gray failure in the leader's local disk"),", and how TigerBeetle\n",(0,r.kt)("strong",{parentName:"p"},"eliminates gray failure in the network links to the replication nodes"),"."),(0,r.kt)("p",null,"Like LMAX, TigerBeetle uses a thread-per-core design for optimal performance, with strict\nsingle-threading to enforce the single-writer principle and to avoid the costs of multi-threaded\ncoordinated access to data."),(0,r.kt)("h2",{id:"data-structures"},"Data Structures"),(0,r.kt)("p",null,"The best way to understand TigerBeetle is through the data structures it provides. All data\nstructures are ",(0,r.kt)("strong",{parentName:"p"},"fixed-size")," for performance and simplicity, and there are two main kinds of data\nstructures, ",(0,r.kt)("strong",{parentName:"p"},"events")," and ",(0,r.kt)("strong",{parentName:"p"},"states"),"."),(0,r.kt)("h3",{id:"events"},"Events"),(0,r.kt)("p",null,"Events are ",(0,r.kt)("strong",{parentName:"p"},"immutable data structures")," that ",(0,r.kt)("strong",{parentName:"p"},"instantiate or mutate state data structures"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Events cannot be changed, not even by other events."),(0,r.kt)("li",{parentName:"ul"},"Events cannot be derived and must therefore be recorded before execution."),(0,r.kt)("li",{parentName:"ul"},"Events must be executed one after another \u2013in deterministic order\u2013 to ensure replayability."),(0,r.kt)("li",{parentName:"ul"},"Events may depend on past events (should they choose)."),(0,r.kt)("li",{parentName:"ul"},"Events cannot depend on future events."),(0,r.kt)("li",{parentName:"ul"},"Events may depend on states being at an exact version (should they choose)."),(0,r.kt)("li",{parentName:"ul"},"Events may succeed or fail, but the result of an event is never stored in the event; it is stored\nin the state instantiated or mutated by the event."),(0,r.kt)("li",{parentName:"ul"},"Events can only have one immutable version, which can be referenced directly by the event's id."),(0,r.kt)("li",{parentName:"ul"},"Events should be retained for auditing purposes. However, events may be drained into a separate\ncold storage system once their effect has been captured in a state snapshot to compact the journal\nand improve startup times.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"create_transfer"),': Create a transfer between accounts (maps to a "prepare"). We group fields in\ndescending order of size to avoid unnecessary struct padding in C implementations.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"          create_transfer {\n                      id: 16 bytes (128-bit)\n        debit_account_id: 16 bytes (128-bit)\n       credit_account_id: 16 bytes (128-bit)\n                  amount: 16 bytes (128-bit) [required, an unsigned integer in the unit of value of the debit and credit accounts, which must be the same for both accounts]\n              pending_id: 16 bytes (128-bit) [optional, required to post or void an existing but pending transfer]\n           user_data_128: 16 bytes (128-bit) [optional, e.g. opaque third-party identifier to link this transfer (many-to-one) to an external entity]\n            user_data_64:  8 bytes ( 64-bit) [optional, e.g. opaque third-party identifier to link this transfer (many-to-one) to an external entity]\n            user_data_32:  4 bytes ( 32-bit) [optional, e.g. opaque third-party identifier to link this transfer (many-to-one) to an external entity]\n                 timeout:  4 bytes ( 32-bit) [optional, required only for a pending transfer, a quantity of time, i.e. an offset in seconds from timestamp]\n                  ledger:  4 bytes ( 32-bit) [required, to enforce isolation by ensuring that all transfers are between accounts of the same ledger]\n                    code:  2 bytes ( 16-bit) [required, an opaque chart of accounts code describing the reason for the transfer, e.g. deposit, settlement]\n                   flags:  2 bytes ( 16-bit) [optional, to modify the usage of the reserved field and for future feature expansion]\n               timestamp:  8 bytes ( 64-bit) [reserved, assigned by the leader before journalling]\n} = 128 bytes (2 CPU cache lines)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"create_account"),": Create an account."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We use the terms ",(0,r.kt)("inlineCode",{parentName:"li"},"credit")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"debit"),' instead of "payable" or "receivable" since the meaning of a\ncredit balance depends on whether the account is an asset or liability or equity, income or\nexpense.'),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"posted")," amount refers to an amount posted by a transfer."),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"pending")," amount refers to an inflight amount yet-to-be-posted by a two-phase transfer only,\nwhere the transfer is still pending, and the transfer timeout has not yet fired. In other words,\nthe transfer amount has been reserved in the pending account balance (to avoid double-spending)\nbut not yet posted to the posted balance. The reserved amount will rollback if the transfer\nultimately fails. By default, transfers post automatically, but being able to reserve the amount\nas pending and then post the amount only later can sometimes be convenient, for example, when\nswitching credit card payments."),(0,r.kt)("li",{parentName:"ul"},"The debit balance of an account is given by adding ",(0,r.kt)("inlineCode",{parentName:"li"},"debits_posted")," plus ",(0,r.kt)("inlineCode",{parentName:"li"},"debits_pending"),",\nlikewise, for the credit balance of an account."),(0,r.kt)("li",{parentName:"ul"},"The total balance of an account can be derived by subtracting the total credit balance from the\ntotal debit balance."),(0,r.kt)("li",{parentName:"ul"},"We keep both sides of the ledger (debit and credit) separate to avoid having to deal with signed\nnumbers and to preserve more information about the nature of an account. For example, two accounts\ncould have the same balance of 0, but one account could have 1,000,000 units on both sides of the\nledger, whereas another account could have 1 unit on both sides, both balancing out to 0."),(0,r.kt)("li",{parentName:"ul"},"Once created, an account may be changed only through transfer events to keep an immutable paper\ntrail for auditing.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"           create_account {\n                      id: 16 bytes (128-bit)\n          debits_pending: 16 bytes (128-bit)\n           debits_posted: 16 bytes (128-bit)\n         credits_pending: 16 bytes (128-bit)\n          credits_posted: 16 bytes (128-bit)\n           user_data_128: 16 bytes (128-bit) [optional, opaque third-party identifier to link this account (many-to-one) to an external entity]\n            user_data_64:  8 bytes ( 64-bit) [optional, opaque third-party identifier to link this account (many-to-one) to an external entity]\n            user_data_32:  4 bytes ( 32-bit) [optional, opaque third-party identifier to link this account (many-to-one) to an external entity]\n                reserved:  4 bytes ( 32-bit) [reserved for future accounting policy primitives]\n                  ledger:  4 bytes ( 32-bit) [required, to enforce isolation by ensuring that all transfers are between accounts of the same ledger]\n                    code:  2 bytes ( 16-bit) [required, an opaque chart of accounts code describing the reason for the transfer, e.g. deposit, settlement]\n                   flags:  2 bytes ( 16-bit) [optional, net balance limits: e.g. debits_must_not_exceed_credits or credits_must_not_exceed_debits]\n               timestamp:  8 bytes ( 64-bit) [reserved]\n} = 128 bytes (2 CPU cache lines)\n")),(0,r.kt)("h3",{id:"states"},"States"),(0,r.kt)("p",null,"States are ",(0,r.kt)("strong",{parentName:"p"},"data structures")," that capture the results of events:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"States can always be derived by replaying all events.")),(0,r.kt)("p",null,"TigerBeetle provides ",(0,r.kt)("strong",{parentName:"p"},"exactly one state data structure"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Account"),": An account showing the effect of all transfers.")),(0,r.kt)("p",null,"To simplify, to reduce memory copies and to reuse the wire format of event data structures as much\nas possible, we reuse our ",(0,r.kt)("inlineCode",{parentName:"p"},"create_account")," event data structure to instantiate the corresponding\nstate data structure."),(0,r.kt)("h2",{id:"protocol"},"Protocol"),(0,r.kt)("p",null,"The current TCP wire protocol is:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a fixed-size header that can be used for requests or responses,"),(0,r.kt)("li",{parentName:"ul"},"followed by variable-length data.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"HEADER (128 bytes)\n16 bytes CHECKSUM (of remaining HEADER)\n16 bytes CHECKSUM BODY\n[...see src/vsr.zig for the rest of the Header definition...]\nDATA (multiples of 64 bytes)\n................................................................................\n................................................................................\n................................................................................\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"DATA")," in ",(0,r.kt)("strong",{parentName:"p"},"the request")," for a ",(0,r.kt)("inlineCode",{parentName:"p"},"create_transfer")," command looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"{ create_transfer event struct }, { create_transfer event struct } etc.\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"All event structures are appended one after the other in the ",(0,r.kt)("inlineCode",{parentName:"li"},"DATA"),".")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"DATA")," in ",(0,r.kt)("strong",{parentName:"p"},"the response")," to a ",(0,r.kt)("inlineCode",{parentName:"p"},"create_transfer")," command looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"{ index: integer, error: integer }, { index: integer, error: integer }, etc.\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Only failed ",(0,r.kt)("inlineCode",{parentName:"li"},"create_transfer")," events emit an ",(0,r.kt)("inlineCode",{parentName:"li"},"error")," struct in the response. We do this to\noptimize the common case where most ",(0,r.kt)("inlineCode",{parentName:"li"},"create_transfer")," events succeed."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"error")," struct includes the ",(0,r.kt)("inlineCode",{parentName:"li"},"index")," into the batch of the ",(0,r.kt)("inlineCode",{parentName:"li"},"create_transfer")," event that failed\nand a TigerBeetle ",(0,r.kt)("inlineCode",{parentName:"li"},"error")," return code indicating why."),(0,r.kt)("li",{parentName:"ul"},"All other ",(0,r.kt)("inlineCode",{parentName:"li"},"create_transfer")," events succeeded."),(0,r.kt)("li",{parentName:"ul"},"This ",(0,r.kt)("inlineCode",{parentName:"li"},"error")," struct response strategy is the same for ",(0,r.kt)("inlineCode",{parentName:"li"},"create_account")," events.")),(0,r.kt)("h3",{id:"protocol-design-decisions"},"Protocol Design Decisions"),(0,r.kt)("p",null,"The header is a multiple of 128 bytes because we want to keep the subsequent data aligned to 64-byte\ncache line boundaries. We don't want any structure to straddle multiple cache lines unnecessarily\nfor the sake of simplicity with respect to struct alignment and because this can have a performance\nimpact through false sharing."),(0,r.kt)("p",null,"We order the header struct as we do to keep any C protocol implementations padding-free."),(0,r.kt)("p",null,"We use AEGIS-128L as our checksum, designed to fully exploit the parallelism and built-in AES\nsupport of recent Intel and ARM CPUs."),(0,r.kt)("p",null,"The reason we use two checksums instead of only a single checksum across header and data is that we\nneed a reliable way to know the size of the data to expect before we start receiving the data."),(0,r.kt)("p",null,"Here is an example showing the risk of a single checksum for the recipient:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"We receive a header with a single checksum protecting both header and data."),(0,r.kt)("li",{parentName:"ol"},"We extract the SIZE of the data from the header (4 GiB in this case)."),(0,r.kt)("li",{parentName:"ol"},"We cannot tell if this SIZE value is corrupt until we receive the data."),(0,r.kt)("li",{parentName:"ol"},"We wait for 4 GiB of data to arrive before calculating/comparing checksums."),(0,r.kt)("li",{parentName:"ol"},"Except the SIZE was corrupted in transit from 16 MiB to 4 GiB (2-bit flips)."),(0,r.kt)("li",{parentName:"ol"},"We never detect the corruption, the connection times out, and we miss our SLA.")))}p.isMDXComponent=!0}}]);