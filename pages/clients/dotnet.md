---
title: .NET
---

This file is generated by
[https://github.com/tigerbeetledb/tigerbeetle/blob/main/src/clients/docs_generate.zig](https://github.com/tigerbeetledb/tigerbeetle/blob/main/src/clients/docs_generate.zig).
# tigerbeetle-dotnet

The TigerBeetle client for .NET.

### Prerequisites

Linux >= 5.6 is the only production environment we
support. But for ease of development we also support macOS and Windows.
* .NET >= 2.1
And if you do not already have NuGet.org as a package
source, make sure to add it:

```console
$ dotnet nuget add source https://api.nuget.org/v3/index.json -n nuget.org
```

## Setup

First, create a directory for your project and `cd` into the directory.

Then, install the TigerBeetle client:

```console
$ dotnet new console
$ dotnet add package tigerbeetle
```

Now, create `Program.cs` and copy this into it:

```cs
using System;

using TigerBeetle;

// Validate import works.
var id = new TigerBeetle.UInt128(1);
Console.WriteLine("SUCCESS");
```

Finally, build and run:

```console
$ dotnet run
```

Now that all prerequisites and dependencies are correctly set
up, let's dig into using TigerBeetle.

## Sample projects

This document is primarily a reference guide to
the client. Below are various sample projects demonstrating
features of TigerBeetle.

* [Basic](https://github.com/tigerbeetledb/tigerbeetle/blob/main/src/clients/dotnet/samples/basic/): Create two accounts and transfer an amount between them.
* [Two-Phase Transfer](https://github.com/tigerbeetledb/tigerbeetle/blob/main/src/clients/dotnet/samples/two-phase/): Create two accounts and start a pending transfer between
them, then post the transfer.
## Creating a Client

A client is created with a cluster ID and replica
addresses for all replicas in the cluster. The cluster
ID and replica addresses are both chosen by the system that
starts the TigerBeetle cluster.

Clients are thread-safe. But for better
performance, a single instance should be shared between
multiple concurrent tasks.

Multiple clients are useful when connecting to more than
one TigerBeetle cluster.

In this example the cluster ID is `0` and there is one
replica. The address is read from the `TB_ADDRESS`
environment variable and defaults to port `3000`.

```cs
var tbAddress = Environment.GetEnvironmentVariable("TB_ADDRESS");
var client = new Client(
  clusterID: 0,
  addresses: new[] {tbAddress != null ? tbAddress : "3000"}
);
```

If you create a `Client` like this, don't forget to call
`client.Dispose()` when you are done with it. Otherwise you
can use the `using` syntax:
```csharp
using (var client = new Client(...)) {
  // Use client
}
```

The `Client` class is thread-safe and for better performance, a
single instance should be shared between multiple concurrent
tasks. Multiple clients can be instantiated in case of connecting
to more than one TigerBeetle cluster.

The following are valid addresses:
* `3000` (interpreted as `127.0.0.1:3000`)
* `127.0.0.1:3000` (interpreted as `127.0.0.1:3000`)
* `127.0.0.1` (interpreted as `127.0.0.1:3001`, `3001` is the default port)

## Creating Accounts

See details for account fields in the [Accounts
reference](https://docs.tigerbeetle.com/reference/accounts).

```cs
var accounts = new[] {
  new Account
  {
    Id = 137,
    UserData = Guid.NewGuid(),
    Ledger = 1,
    Code = 718,
    Flags = AccountFlags.None,
  },     
};

var createAccountsError = client.CreateAccounts(accounts);
```

All TigerBeetle's IDs are 128-bit integers, and the .NET client
accepts a wide range of values: `int`, `uint`, `long`, `ulong`,
`Guid`, `byte[]` and `TigerBeetle.UInt128`.

### Account Flags

The account flags value is a bitfield. See details for
these flags in the [Accounts
reference](https://docs.tigerbeetle.com/reference/accounts#flags).

To toggle behavior for an account, combine enum values stored in the
`AccountFlags` object with bitwise-or:

* `AccountFlags.None`
* `AccountFlags.Linked`
* `AccountFlags.DebitsMustNotExceedCredits`
* `AccountFlags.CreditsMustNotExceedDebits`

For example, to link two accounts where the first account
additionally has the `debits_must_not_exceed_credits` constraint:

```cs
var account0 = new Account{ /* ... account values ... */ };
var account1 = new Account{ /* ... account values ... */ };
account0.Flags = AccountFlags.Linked;

createAccountsError = client.CreateAccounts(new []{account0, account1});
```

### Response and Errors

The response is an empty array if all accounts were
created successfully. If the response is non-empty, each
object in the response array contains error information
for an account that failed. The error object contains an
error code and the index of the account in the request
batch.

See all error conditions in the [create_accounts
reference](https://docs.tigerbeetle.com/reference/operations/create_accounts).

```cs
var account2 = new Account{ /* ... account values ... */ };
var account3 = new Account{ /* ... account values ... */ };
var account4 = new Account{ /* ... account values ... */ };

createAccountsError = client.CreateAccounts(new []{account2, account3, account4});
foreach (var error in createAccountsError) {
	Console.WriteLine("Error creating account {0}: {1}", error.Index, error.Result);
	return;
}
```

## Account Lookup

Account lookup is batched, like account creation. Pass
in all IDs to fetch. The account for each matched ID is returned.

If no account matches an ID, no object is returned for
that account. So the order of accounts in the response is
not necessarily the same as the order of IDs in the
request. You can refer to the ID field in the response to
distinguish accounts.

```cs
accounts = client.LookupAccounts(new TigerBeetle.UInt128[] { 137, 138 });
```

## Create Transfers

This creates a journal entry between two accounts.

See details for transfer fields in the [Transfers
reference](https://docs.tigerbeetle.com/reference/transfers).

```cs
var transfers = new[] {
  new Transfer
  {
    Id = 1,
    DebitAccountId = 1,
    CreditAccountId = 2,
    Timeout = 0,
    UserData = 2,
    Ledger = 1,
    Code = 1,
    Flags = 0,
    Amount = 10,
  }
};

var createTransfersError = client.CreateTransfers(transfers);
```

### Response and Errors

The response is an empty array if all transfers were created
successfully. If the response is non-empty, each object in the
response array contains error information for an transfer that
failed. The error object contains an error code and the index of the
transfer in the request batch.

See all error conditions in the [create_transfers
reference](https://docs.tigerbeetle.com/reference/operations/create_transfers).

```cs
foreach (var error in createTransfersError) {
  Console.WriteLine("Error creating account {0}: {1}", error.Index, error.Result);
  return;
}
```

## Batching

TigerBeetle performance is maximized when you batch
API requests. The client does not do this automatically for
you. So, for example, you *can* insert 1 million transfers
one at a time like so:

```cs
foreach(var t in transfers) {
  createTransfersError = client.CreateTransfers(new []{t});
  // error handling omitted
}
```

But the insert rate will be a *fraction* of
potential. Instead, **always batch what you can**.

The maximum batch size is set in the TigerBeetle server. The default
is 8191.

```cs
var BATCH_SIZE = 8191;
for (int i = 0; i < transfers.Length; i += BATCH_SIZE) {
  var batchSize = BATCH_SIZE;
  if (i + BATCH_SIZE > transfers.Length) {
    batchSize = transfers.Length - i;
  }
  var segment = new ArraySegment<Transfer>(transfers, i, batchSize);
  createTransfersError = client.CreateTransfers(segment.Array);
  // error handling omitted
}
```

### Queues and Workers

If you are making requests to TigerBeetle from workers
pulling jobs from a queue, you can batch requests to
TigerBeetle by having the worker act on multiple jobs from
the queue at once rather than one at a time. i.e. pulling
multiple jobs from the queue rather than just one.

## Transfer Flags

The transfer `flags` value is a bitfield. See details for these flags in
the [Transfers
reference](https://docs.tigerbeetle.com/reference/transfers#flags).

To toggle behavior for an account, combine enum values stored in the
`TransferFlags` object with bitwise-or:

* `TransferFlags.None`
* `TransferFlags.Linked`
* `TransferFlags.Pending`
* `TransferFlags.PostPendingTransfer`
* `TransferFlags.VoidPendingTransfer`

For example, to link `transfer0` and `transfer1`:

```cs
var transfer0 = new Transfer{ /* ... account values ... */ };
var transfer1 = new Transfer{ /* ... account values ... */ };
transfer0.Flags = TransferFlags.Linked;
createTransfersError = client.CreateTransfers(new Transfer[] {transfer0, transfer1});
```

### Two-Phase Transfers

Two-phase transfers are supported natively by toggling the appropriate
flag. TigerBeetle will then adjust the `credits_pending` and
`debits_pending` fields of the appropriate accounts. A corresponding
post pending transfer then needs to be sent to post or void the
transfer.

#### Post a Pending Transfer

With `flags` set to `post_pending_transfer`,
TigerBeetle will post the transfer. TigerBeetle will atomically roll
back the changes to `debits_pending` and `credits_pending` of the
appropriate accounts and apply them to the `debits_posted` and
`credits_posted` balances.

```cs
var transfer = new Transfer
{
  Id = 2,
  PendingId = 1,
  Flags = TransferFlags.PostPendingTransfer,
};
createTransfersError = client.CreateTransfers(new Transfer[] {transfer});
// error handling omitted
```

#### Void a Pending Transfer

In contrast, with `flags` set to `void_pending_transfer`,
TigerBeetle will void the transfer. TigerBeetle will roll
back the changes to `debits_pending` and `credits_pending` of the
appropriate accounts and **not** apply them to the `debits_posted` and
`credits_posted` balances.

```cs
transfer = new Transfer
{
  Id = 2,
  PendingId = 1,
  Flags = TransferFlags.PostPendingTransfer,
};
createTransfersError = client.CreateTransfers(new Transfer[] {transfer});
// error handling omitted
```

## Transfer Lookup

NOTE: While transfer lookup exists, it is not a flexible query API. We
are developing query APIs and there will be new methods for querying
transfers in the future.

Transfer lookup is batched, like transfer creation. Pass in all `id`s to
fetch, and matched transfers are returned.

If no transfer matches an `id`, no object is returned for that
transfer. So the order of transfers in the response is not necessarily
the same as the order of `id`s in the request. You can refer to the
`id` field in the response to distinguish transfers.

```cs
transfers = client.LookupTransfers(new TigerBeetle.UInt128[] {1, 2});
```

## Linked Events

When the `linked` flag is specified for an account when creating accounts or
a transfer when creating transfers, it links that event with the next event in the
batch, to create a chain of events, of arbitrary length, which all
succeed or fail together. The tail of a chain is denoted by the first
event without this flag. The last event in a batch may therefore never
have the `linked` flag set as this would leave a chain
open-ended. Multiple chains or individual events may coexist within a
batch to succeed or fail independently.

Events within a chain are executed within order, or are rolled back on
error, so that the effect of each event in the chain is visible to the
next, and so that the chain is either visible or invisible as a unit
to subsequent events after the chain. The event that was the first to
break the chain will have a unique error result. Other events in the
chain will have their error result set to `linked_event_failed`.

```cs
var batch = new System.Collections.Generic.List<Transfer>();

// An individual transfer (successful):
batch.Add(new Transfer{Id = 1, /* ... rest of transfer ... */ });

// A chain of 4 transfers (the last transfer in the chain closes the chain with linked=false):
batch.Add(new Transfer{Id = 2, /* ... rest of transfer ... */ Flags = TransferFlags.Linked }); // Commit/rollback.
batch.Add(new Transfer{Id = 3, /* ... rest of transfer ... */ Flags = TransferFlags.Linked }); // Commit/rollback.
batch.Add(new Transfer{Id = 2, /* ... rest of transfer ... */ Flags = TransferFlags.Linked }); // Fail with exists
batch.Add(new Transfer{Id = 4, /* ... rest of transfer ... */ }); // Fail without committing

// An individual transfer (successful):
// This should not see any effect from the failed chain above.
batch.Add(new Transfer{Id = 2, /* ... rest of transfer ... */ });

// A chain of 2 transfers (the first transfer fails the chain):
batch.Add(new Transfer{Id = 2, /* ... rest of transfer ... */ Flags = TransferFlags.Linked });
batch.Add(new Transfer{Id = 3, /* ... rest of transfer ... */ });

// A chain of 2 transfers (successful):
batch.Add(new Transfer{Id = 3, /* ... rest of transfer ... */ Flags = TransferFlags.Linked });
batch.Add(new Transfer{Id = 4, /* ... rest of transfer ... */ });

createTransfersError = client.CreateTransfers(batch.ToArray());
// error handling omitted
```

## Development Setup

### On Linux and macOS

In a POSIX shell run:

```console
$ git clone https://github.com/tigerbeetledb/tigerbeetle
$ cd tigerbeetle
$ git submodule update --init --recursive
$ ./scripts/install_zig.sh
$ cd src/clients/dotnet
$ dotnet restore
$ dotnet clean
$ dotnet build
$ if [ "$TEST" = "true" ]; then dotnet test; else echo "Skipping client unit tests"; fi
```

### On Windows

In PowerShell run:

```console
$ git clone https://github.com/tigerbeetledb/tigerbeetle
$ cd tigerbeetle
$ git submodule update --init --recursive
$ .\scripts\install_zig.bat
$ cd src/clients/dotnet
$ dotnet restore
$ dotnet clean
$ dotnet build
$ if ($env:TEST -eq 'true') { dotnet test } else { echo "Skipping client unit test" }
```

