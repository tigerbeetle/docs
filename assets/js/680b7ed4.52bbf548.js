"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6566],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i=n.createContext({}),c=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(i.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=c(a),h=r,m=u["".concat(i,".").concat(h)]||u[h]||d[h]||l;return a?n.createElement(m,s(s({ref:t},p),{},{components:a})):n.createElement(m,s({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,s=new Array(l);s[0]=h;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o[u]="string"==typeof e?e:r,s[1]=o;for(var c=2;c<l;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},8880:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const l={sidebar_position:2},s="Data File",o={unversionedId:"internals/data_file",id:"internals/data_file",title:"Data File",description:"\u201cJust show me the tables already!\u201d",source:"@site/pages/internals/data_file.md",sourceDirName:"internals",slug:"/internals/data_file",permalink:"/internals/data_file",draft:!1,editUrl:"https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/internals/data_file.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"VSR",permalink:"/internals/vsr"},next:{title:"LSM",permalink:"/internals/lsm"}},i={},c=[],p={toc:c},u="wrapper";function d(e){let{components:t,...a}=e;return(0,r.kt)(u,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"data-file"},"Data File"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\u201cJust show me the tables already!\u201d\n\u2014 probably not Fred Brooks")),(0,r.kt)("p",null,"Each TigerBeetle replica stores all data inside a single file, called the data file (conventional\nextension is ",(0,r.kt)("inlineCode",{parentName:"p"},".tigerbeetle"),"). This document describes the high level layout of the data file. The\npresentation is simplified a bit, to provide intuition without drowning the reader in details.\nConsult the source code for byte-level details!"),(0,r.kt)("p",null,"The data file is divided into several zones, with the main ones being:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"write-ahead log"),(0,r.kt)("li",{parentName:"ul"},"superblock"),(0,r.kt)("li",{parentName:"ul"},"grid")),(0,r.kt)("p",null,"The grid forms the bulk of the data file (up to several terabytes). It is an elastic array of 64KiB\nblocks:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-zig"},"pub const Block = [constants.block_size]u8;\npub const BlockPtr = *align(constants.sector_size) Block;\n")),(0,r.kt)("p",null,"The grid serves as a raw storage layer. Higher level data structures (notably, the LSM tree) are\nmapped to physical grid blocks. Because TigerBeetle is deterministic, the used portion of the grid\nis identical across up-to-date replicas. This storage determinism is exploited to implement state\nsync and repair on the level of grid blocks, see ",(0,r.kt)("a",{parentName:"p",href:"/internals/vsr#protocol-repair-grid"},"the repair protocol"),"."),(0,r.kt)("p",null,"A grid block is identified by a pair of a ",(0,r.kt)("inlineCode",{parentName:"p"},"u64")," index and ",(0,r.kt)("inlineCode",{parentName:"p"},"u128")," checksum:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-zig"},"pub const BlockReference = struct {\n    index: u64,\n    checksum: u128,\n};\n")),(0,r.kt)("p",null,'The block checksum is stored outside of the block itself, to protect from misdirected writes. So, to\nread a block, you need to know the block\'s index and checksum from "elsewhere", where "elsewhere" is\neither a different block, or the superblock. Overall, the grid is used to implement a purely\nfunctional, persistent (in both senses), garbage collected data structure which is updated\natomically by swapping the pointer to the root node. This is the classic copy-on-write technique\ncommonly used in filesystems. In fact, you can think of TigerBeetle\'s data file as a filesystem.'),(0,r.kt)("p",null,'The superblock is what holds this logical "root pointer". Physically, the "root pointer" is comprised\nof a couple of block references. These blocks, taken together, specify the manifests of all LSM trees.'),(0,r.kt)("p",null,"Superblock is located at a fixed position in the data file, so, when a replica starts up, it can\nread the superblock, read root block indexes and hashes from the superblock, and through those get\naccess to the rest of the data in the grid. Besides the manifest, superblock also stores a\ncompressed bitset of all grid blocks which are not currently allocated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-zig"},"pub const SuperBlock = struct {\n    manifest_oldest: BlockReference,\n    manifest_newest: BlockReference,\n    free_set: BitSet,\n};\n")),(0,r.kt)("p",null,'Superblock durable updates must be atomic and need to write a fair amount of data (several\nmegabytes). To amortize this cost, superblock is flushed to disk relatively infrequently. The normal\nmode of operation is that a replica starts up, reads the current superblock and free set to memory,\nthen proceeds allocating and writing new grid blocks, picking up free entries from the bit set. That\nis, although the replica does write freshly allocated grid blocks to disk immediately, it does not\nupdate the superblock on disk (so the logical state reachable from the superblock stays the same).\nOnly after a relatively large amount of new grid blocks are written, the replica atomically writes\nthe new superblock, with a new free set and a new logical "root pointer" (the superblock manifest).\nIf the replica crashes and restarts, it starts from the previous superblock, but, due to\ndeterminism, replaying the operations after the crash results in exactly the same on-disk and\nin-memory state.'),(0,r.kt)("p",null,"To implement atomic update of the superblock, the superblock is physically stored as 4\ndistinct copies on disk. After startup, replica picks the latest superblock which has at least 2\ncopies written. Picking just the latest copy would be wrong --- unlike the grid blocks, the\nsuperblock stores its own checksum, and is vulnerable to misdirected reads (i.e., a misdirected read\ncan hide the sole latest copy)."),(0,r.kt)("p",null,"Because the superblock (and hence, logical grid state) is updated infrequently and in bursts, it\ncan't represent the entirety of persistent state. The rest of the state is stored in the write-ahead\nlog (WAL). The WAL is a ring buffer with prepares, and represents the logical diff which should be\napplied to the state represented by superblock/grid to get the actual current state of the system.\nWAL inner workings are described in the ",(0,r.kt)("a",{parentName:"p",href:"/internals/vsr#protocol-normal"},"VSR documentation"),", but, on a\nhigh-level, when a replica processes a prepare, the replica:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"writes the prepare to the WAL on disk"),(0,r.kt)("li",{parentName:"ul"},"applies changes from the prepare to the in-memory data structure representing the current state"),(0,r.kt)("li",{parentName:"ul"},"applies changes from the prepare to the pending on-disk state by allocating and writing fresh grid\nblocks")),(0,r.kt)("p",null,"When enough prepares are received, the superblock is updated to point to the accumulated-so-far new\ndisk state."),(0,r.kt)("p",null,"This covers how the three major areas of the data file -- the write-ahead log, the superblock and\nthe grid -- work together to represent abstract persistent logical state."),(0,r.kt)("p",null,"Concretely, the state of TigerBeetle is a collection (forest) of LSM trees. LSM structure is\ndescribed ",(0,r.kt)("a",{parentName:"p",href:"/internals/lsm"},"in a separate document"),", here only high level on-disk layout is discussed."),(0,r.kt)("p",null,"Each LSM tree stores a set of values. Values are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"uniform in size,"),(0,r.kt)("li",{parentName:"ul"},"small (hundreds of bytes),"),(0,r.kt)("li",{parentName:"ul"},"sorted by key,"),(0,r.kt)("li",{parentName:"ul"},"which is embedded in the value itself (e.g, an ",(0,r.kt)("inlineCode",{parentName:"li"},"Account")," value uses ",(0,r.kt)("inlineCode",{parentName:"li"},"timestamp")," as a unique key).")),(0,r.kt)("p",null,"To start from the middle, values are arranged in tables on disk. Each table represents a sorted\narray of values and is physically stored in multiple blocks. Specifically:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A table's data blocks each store a sorted array of values."),(0,r.kt)("li",{parentName:"ul"},"A table's index block stores pointers to the data blocks, as well as boundary keys.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-zig"},"const TableDataBlock = struct {\n    values_sorted: [value_count_max]Value,\n};\n\nconst TableIndexBlock = struct {\n    data_block_checksums: [data_block_count_max]u128,\n    data_block_indexes:   [data_block_count_max]u64,\n    data_block_key_max:   [data_block_count_max]Key,\n};\n\nconst TableInfo = struct {\n    tree_id: u16,\n    index_block_index: u64,\n    index_block_checksum: u128,\n    key_min: Key,\n    key_max: Key,\n};\n")),(0,r.kt)("p",null,"To lookup a value in a table, binary search the index block to locate the data block which should\nhold the value, then binary search inside the data block."),(0,r.kt)("p",null,"Table size is physically limited by a single index block which can hold only so many references to\ndata blocks. However, tables are further artificially limited to hold only a certain (compile-time\nconstant) number of entries. Tables are arranged in levels. Each subsequent level contains\nexponentially more tables."),(0,r.kt)("p",null,"Tables in a single level are pairwise disjoint. Tables in different layers overlap, but the key LSM:\ninvariant is observed: values in shallow layers override values in deeper layers. This means that\nall modification happen to the first (purely in-memory) level."),(0,r.kt)("p",null,"An asynchronous compaction process rebalances layers. Compaction removes one table from level A, finds\nall tables from level A+1 that intersect that table, removes all those tables from level A+1 and\ninserts the result of the intersection."),(0,r.kt)("p",null,"Schematically, the effect of compaction can be represented as a sequence of events:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-zig"},"const CompactionEvent = struct {\n    label: Label\n    table: TableInfo, // points to table's index block\n};\n\nconst Label = struct {\n    level: u6,\n    event: enum(u2) { insert, update, remove },\n};\n")),(0,r.kt)("p",null,"What's more, the current state of a tree can be represented implicitly as a sequence of such\ninsertion and removal events, which starts from the empty set of tables. And that's exactly how it\nis represented physically in a data file!"),(0,r.kt)("p",null,"Specifically, each LSM tree is a collection of layers which is stored implicitly as log of events.\nThe log consists of a sequence of ",(0,r.kt)("inlineCode",{parentName:"p"},"ManifestBlock"),"s:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-zig"},"const ManifestBlock = struct {\n  previous_manifest_block: BlockReference,\n  labels: [entry_count_max]Label,\n  tables: [entry_count_max]TableInfo,\n};\n")),(0,r.kt)("p",null,"The manifest is an on-disk (in-grid) linked list, where each manifest block holds a reference to the\nprevious block."),(0,r.kt)("p",null,"The superblock then stores the oldest and newest manifest log blocks for all trees:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-zig"},"const Superblock = {\n  manifest_block_oldest_address: u64,\n  manifest_block_oldest_checksum: u128,\n  manifest_block_newest_address: u64,\n  manifest_block_newest_checksum: u128,\n  free_set: BitSet,\n};\n")),(0,r.kt)("p",null,"Tying everything together:"),(0,r.kt)("p",null,"State is represented as a collection of LSM trees. Superblock is the root of all state. For each LSM\ntree, superblock contains the pointers to the blocks constituting each tree's manifest log -- a sequence\nof individual tables additions and deletions. By replaying this manifest log, it is possible to\nreconstruct the manifest in memory. ",(0,r.kt)("inlineCode",{parentName:"p"},"Manifest")," describes levels and tables of a single LSM tree. A\ntable is a pointer to its index block. The index block is a sorted array of pointers to data blocks.\nData blocks are sorted arrays of values."))}d.isMDXComponent=!0}}]);