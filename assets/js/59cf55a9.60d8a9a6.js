"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4317],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},s=Object.keys(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=i.createContext({}),c=function(e){var t=i.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return i.createElement(o.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,o=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),d=r,h=p["".concat(o,".").concat(d)]||p[d]||m[d]||s;return n?i.createElement(h,a(a({ref:t},u),{},{components:n})):i.createElement(h,a({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,a=new Array(s);a[0]=d;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[p]="string"==typeof e?e:r,a[1]=l;for(var c=2;c<s;c++)a[c]=n[c];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9931:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var i=n(7462),r=(n(7294),n(3905));const s={sidebar_position:6},a="Client Sessions",l={unversionedId:"reference/sessions",id:"reference/sessions",title:"Client Sessions",description:"A client session is a sequence of requests and replies sent between a",source:"@site/pages/reference/sessions.md",sourceDirName:"reference",slug:"/reference/sessions",permalink:"/reference/sessions",draft:!1,editUrl:"https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/reference/sessions.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"lookup_transfers",permalink:"/reference/requests/lookup_transfers"},next:{title:"About TigerBeetle",permalink:"/about/"}},o={},c=[{value:"Lifecycle",id:"lifecycle",level:2},{value:"Eviction",id:"eviction",level:2},{value:"Retries",id:"retries",level:2},{value:"Guarantees",id:"guarantees",level:2}],u={toc:c},p="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"client-sessions"},"Client Sessions"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"client session")," is a sequence of ",(0,r.kt)("a",{parentName:"p",href:"/reference/requests/"},"requests")," and replies sent between a\nclient and a cluster."),(0,r.kt)("p",null,"A client session may have ",(0,r.kt)("strong",{parentName:"p"},"at most one in-flight request")," \u2014 i.e. at most one unique request on the\nnetwork for which a reply has not been received. This simplifies consistency and allows the cluster\nto statically guarantee capacity in its incoming message queue. Additional requests from the\napplication are queued by the client, to be dequeued and sent when their preceding request receives\na reply."),(0,r.kt)("p",null,"Similar to other databases, TigerBeetle has a ",(0,r.kt)("a",{parentName:"p",href:"#eviction"},"hard limit")," on the number of concurrent\nclient sessions. To maximize throughput, users are encouraged to minimize the number of concurrent\nclients and ",(0,r.kt)("a",{parentName:"p",href:"/reference/requests/#batching-events"},"batch")," as many events as possible per request."),(0,r.kt)("h2",{id:"lifecycle"},"Lifecycle"),(0,r.kt)("p",null,"A client session begins when a client registers itself with the cluster."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'Each client session has a unique identifier ("client id") \u2014 an ephemeral random 128-bit id.'),(0,r.kt)("li",{parentName:"ul"},'The client sends a special "register" message which is committed by the cluster, at which point\nthe client is "registered" \u2014 once it receives the reply, it may begin sending requests.'),(0,r.kt)("li",{parentName:"ul"},"Client registration is handled automatically by the TigerBeetle client implementation when the\nclient is initialized, before it sends its first request."),(0,r.kt)("li",{parentName:"ul"},"When a client restarts (for example, the application service running the TigerBeetle client is\nrestarted) it does not resume its old session \u2014 it starts a new session, with a new (random)\nclient id.")),(0,r.kt)("p",null,"A client session ends when either:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the client session is ",(0,r.kt)("a",{parentName:"li",href:"#eviction"},"evicted"),", or"),(0,r.kt)("li",{parentName:"ul"},"the client terminates")),(0,r.kt)("p",null,"\u2014 whichever occurs first."),(0,r.kt)("h2",{id:"eviction"},"Eviction"),(0,r.kt)("p",null,"When a client session is registering and the number of active sessions in the cluster is already at\nthe cluster's concurrent client session\n",(0,r.kt)("a",{parentName:"p",href:"https://tigerbeetle.com/blog/a-database-without-dynamic-memory/"},"limit")," (",(0,r.kt)("inlineCode",{parentName:"p"},"config.clients_max"),", 32\nby default), an existing client session must be evicted to make space for the new session."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"After a session is evicted by the cluster, no future requests from that session will ever execute."),(0,r.kt)("li",{parentName:"ul"},"The evicted session is chosen as the session that committed a request the longest time ago.")),(0,r.kt)("p",null,"The cluster sends a message to notify the evicted session that it has ended. Typically the evicted\nclient is no longer active (already terminated), but if it is active, the eviction message causes it\nto self-terminate, bubbling up to the application as an ",(0,r.kt)("inlineCode",{parentName:"p"},"session evicted")," error."),(0,r.kt)("p",null,"(TODO: Right now evicted clients panic \u2014 fix that so this is accurate.)"),(0,r.kt)("p",null,"If active clients are terminating with ",(0,r.kt)("inlineCode",{parentName:"p"},"session evicted")," errors, it most likely indicates that the\napplication is trying to run too many concurrent clients. For performance reasons, it is recommended\nto ",(0,r.kt)("a",{parentName:"p",href:"/reference/requests/#batching-events"},"batch")," as many events as possible into each request sent\nby each client."),(0,r.kt)("h2",{id:"retries"},"Retries"),(0,r.kt)("p",null,"A client session will automatically retry a request until either:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the client receives a corresponding reply from the cluster, or"),(0,r.kt)("li",{parentName:"ul"},"the client is terminated.")),(0,r.kt)("p",null,"Unlike most database or RPC clients:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the TigerBeetle client will never time out"),(0,r.kt)("li",{parentName:"ul"},"the TigerBeetle client has no retry limits"),(0,r.kt)("li",{parentName:"ul"},"the TigerBeetle client does not surface network errors")),(0,r.kt)("p",null,"With TigerBeetle's strict consistency model, surfacing these errors at the client/application level\nwould be misleading. An error would imply that a request did not execute, when that is not known:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A request delayed by the network could execute after its timeout."),(0,r.kt)("li",{parentName:"ul"},"A reply delayed by the network could execute before its timeout.")),(0,r.kt)("h2",{id:"guarantees"},"Guarantees"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A client session may have at most one in-flight ",(0,r.kt)("a",{parentName:"li",href:"/reference/requests/"},"request"),"."),(0,r.kt)("li",{parentName:"ul"},"A client session ",(0,r.kt)("a",{parentName:"li",href:"https://jepsen.io/consistency/models/read-your-writes"},"reads its own writes"),",\nmeaning that read operations that happen after a given write operation will observe the effects of\nthe write."),(0,r.kt)("li",{parentName:"ul"},"A client session observes writes in the order that they occur on the cluster."),(0,r.kt)("li",{parentName:"ul"},"A client session observes ",(0,r.kt)("a",{parentName:"li",href:"/reference/account#debits_posted"},(0,r.kt)("inlineCode",{parentName:"a"},"debits_posted"))," and\n",(0,r.kt)("a",{parentName:"li",href:"/reference/account#credits_posted"},(0,r.kt)("inlineCode",{parentName:"a"},"credits_posted"))," as monotonically increasing. That is, a client\nsession will never see ",(0,r.kt)("inlineCode",{parentName:"li"},"credits_posted")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"debits_posted")," decrease."),(0,r.kt)("li",{parentName:"ul"},"A client session never observes uncommitted updates."),(0,r.kt)("li",{parentName:"ul"},"A client session never observes a broken invariant (e.g.\n",(0,r.kt)("a",{parentName:"li",href:"/reference/account#flagscredits_must_not_exceed_debits"},(0,r.kt)("inlineCode",{parentName:"a"},"flags.credits_must_not_exceed_debits"))," or\n",(0,r.kt)("a",{parentName:"li",href:"/reference/transfer#flagslinked"},(0,r.kt)("inlineCode",{parentName:"a"},"flags.linked")),")."),(0,r.kt)("li",{parentName:"ul"},"Multiple client sessions may receive replies out of order relative to one another. For example, if\ntwo clients submit requests around the same time, the client whose request is committed first\nmight receive the reply later."),(0,r.kt)("li",{parentName:"ul"},"A client session can consider a request executed when it receives a reply for the request."),(0,r.kt)("li",{parentName:"ul"},"If a client session is terminated and restarts, it is guaranteed to see the effects of updates for\nwhich the corresponding reply was received prior to termination."),(0,r.kt)("li",{parentName:"ul"},"If a client session is terminated and restarts, it is ",(0,r.kt)("em",{parentName:"li"},"not")," guaranteed to see the effects of\nupdates for which the corresponding reply was ",(0,r.kt)("em",{parentName:"li"},"not")," received prior to the restart. Those updates\nmay occur at any point in the future, or never. Handling application crash recovery safely\nrequires ",(0,r.kt)("a",{parentName:"li",href:"/coding/reliable-transaction-submission"},"using ",(0,r.kt)("inlineCode",{parentName:"a"},"id"),"s to idempotently retry events"),".")))}m.isMDXComponent=!0}}]);