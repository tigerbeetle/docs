"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7052],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=r.createContext({}),p=function(e){var t=r.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(o.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=a,h=u["".concat(o,".").concat(m)]||u[m]||d[m]||i;return n?r.createElement(h,s(s({ref:t},c),{},{components:n})):r.createElement(h,s({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=m;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[u]="string"==typeof e?e:a,s[1]=l;for(var p=2;p<i;p++)s[p]=n[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7096:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=n(7462),a=(n(7294),n(3905));const i={sidebar_position:5},s="Consistency",l={unversionedId:"design/consistency",id:"design/consistency",title:"Consistency",description:"TigerBeetle is designed to guard against bugs not only in its [own",source:"@site/pages/design/consistency.md",sourceDirName:"design",slug:"/design/consistency",permalink:"/design/consistency",draft:!1,editUrl:"https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/design/consistency.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Client Sessions",permalink:"/design/client-sessions"},next:{title:"Time",permalink:"/design/time"}},o={},p=[{value:"Guarantees",id:"guarantees",level:2},{value:"Sessions",id:"sessions",level:4},{value:"Requests",id:"requests",level:4},{value:"Events",id:"events",level:4},{value:"Accounts",id:"accounts",level:4},{value:"Transfers",id:"transfers",level:4},{value:"Reply Order",id:"reply-order",level:3},{value:"Example",id:"example",level:4},{value:"Retries",id:"retries",level:3},{value:"Consistency with Foreign Databases",id:"consistency-with-foreign-databases",level:3},{value:"Example",id:"example-1",level:4}],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"consistency"},"Consistency"),(0,a.kt)("p",null,"TigerBeetle is designed to guard against bugs not only in its ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/TIGER_STYLE.md"},"own\ncode"),", but at the\nboundaries, in the application code which interfaces with TigerBeetle. This is exhibited by the\nclient's API design, which may be surprising (see ",(0,a.kt)("a",{parentName:"p",href:"#retries"},"Retries"),") when contrasted with a more\nconventional database."),(0,a.kt)("p",null,"Strict consistency guarantees (at the database level) simplify 1) application logic and 2) error\nhandling farther up the stack."),(0,a.kt)("h2",{id:"guarantees"},"Guarantees"),(0,a.kt)("p",null,"TigerBeetle provides strict serializability (",(0,a.kt)("a",{parentName:"p",href:"http://www.bailis.org/blog/linearizability-versus-serializability/"},"serializability +\nlinearizability"),") to each\n",(0,a.kt)("a",{parentName:"p",href:"/design/client-sessions"},"client session"),"."),(0,a.kt)("p",null,"But consistency models can seem arcane. What specific guarantees does TigerBeetle provide to\napplications?"),(0,a.kt)("h4",{id:"sessions"},(0,a.kt)("a",{parentName:"h4",href:"/design/client-sessions"},"Sessions")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A client session may have at most one in-flight ",(0,a.kt)("a",{parentName:"li",href:"/design/client-requests"},"request"),"."),(0,a.kt)("li",{parentName:"ul"},"A client session ",(0,a.kt)("a",{parentName:"li",href:"https://jepsen.io/consistency/models/read-your-writes"},"reads its own writes"),",\nmeaning that read operations that happen after a given write operation will observe the effects of\nthe write."),(0,a.kt)("li",{parentName:"ul"},"A client session observes writes in the order that they occur on the cluster."),(0,a.kt)("li",{parentName:"ul"},"A client session observes ",(0,a.kt)("a",{parentName:"li",href:"/reference/accounts#debits_posted"},(0,a.kt)("inlineCode",{parentName:"a"},"debits_posted"))," and\n",(0,a.kt)("a",{parentName:"li",href:"/reference/accounts#credits_posted"},(0,a.kt)("inlineCode",{parentName:"a"},"credits_posted"))," as monotonically increasing. That is,\na client session will never see ",(0,a.kt)("inlineCode",{parentName:"li"},"credits_posted")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"debits_posted")," decrease."),(0,a.kt)("li",{parentName:"ul"},"A client session never observes uncommitted updates."),(0,a.kt)("li",{parentName:"ul"},"A client session never observes a broken invariant (e.g.\n",(0,a.kt)("a",{parentName:"li",href:"/reference/accounts#flagscredits_must_not_exceed_debits"},(0,a.kt)("inlineCode",{parentName:"a"},"flags.credits_must_not_exceed_debits")),"\nor ",(0,a.kt)("a",{parentName:"li",href:"/reference/transfers#flagslinked"},(0,a.kt)("inlineCode",{parentName:"a"},"flags.linked")),")."),(0,a.kt)("li",{parentName:"ul"},"Multiple client sessions may receive replies ",(0,a.kt)("a",{parentName:"li",href:"#reply-order"},"out of order")," relative to one another.\nFor example, if two clients submit requests around the same time, the client whose request is\ncommitted first might receive the reply later."),(0,a.kt)("li",{parentName:"ul"},"A client session can consider a request executed when it receives a reply for the request.")),(0,a.kt)("h4",{id:"requests"},(0,a.kt)("a",{parentName:"h4",href:"/design/client-requests"},"Requests")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that a request refers to a batch, rather than a single event.")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A request executes within the cluster at most once."),(0,a.kt)("li",{parentName:"ul"},"Requests do not ",(0,a.kt)("a",{parentName:"li",href:"#retries"},"time out"),". Clients will continuously retry requests until they receive\na reply from the cluster. This is because in the case of a network partition, a lack of response\nfrom the cluster could either indicate that the request was dropped before it was processed or\nthat the reply was dropped after the request was processed. Note that individual ",(0,a.kt)("a",{parentName:"li",href:"/design/two-phase-transfers"},"pending\ntransfers")," within a request may have\n",(0,a.kt)("a",{parentName:"li",href:"/reference/transfers#timeout"},"timeouts"),"."),(0,a.kt)("li",{parentName:"ul"},"Requests retried by their original client session receive identical replies."),(0,a.kt)("li",{parentName:"ul"},"Requests retried by a different client (same request body, different session) may receive\n",(0,a.kt)("a",{parentName:"li",href:"#consistency-with-foreign-databases"},"different replies"),"."),(0,a.kt)("li",{parentName:"ul"},"Events within a request are executed in sequence. The effects of a given event are observable when\nthe next event within that request is applied."),(0,a.kt)("li",{parentName:"ul"},"Events within a request do not interleave with events from other requests."),(0,a.kt)("li",{parentName:"ul"},"All events within a request batch are committed, or none are. Note that this does not mean that\nall of the events in a batch will succeed, or that all will fail. Events succeed or fail\nindependently unless they are explicitly ",(0,a.kt)("a",{parentName:"li",href:"/design/client-requests#linked-events"},"linked"))),(0,a.kt)("h4",{id:"events"},(0,a.kt)("a",{parentName:"h4",href:"/reference/operations/"},"Events")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Once committed, an event will always be committed \u2014 the cluster's state never backtracks."),(0,a.kt)("li",{parentName:"ul"},"Within a cluster, object ",(0,a.kt)("a",{parentName:"li",href:"/design/time#timestamps-are-totally-ordered"},"timestamps are unique and strictly\nincreasing"),". No two objects within the same cluster will\nhave the same timestamp. Furthermore, the order of the timestamps indicates the order in which the\nobjects were committed."),(0,a.kt)("li",{parentName:"ul"},"If a client session is terminated and restarts, it is guaranteed to see the effects of updates for\nwhich the corresponding reply was received prior to termination."),(0,a.kt)("li",{parentName:"ul"},"If a client session is terminated and restarts, it is ",(0,a.kt)("em",{parentName:"li"},"not")," guaranteed to see the effects of\nupdates for which the corresponding reply was ",(0,a.kt)("em",{parentName:"li"},"not")," received prior to the restart. Those updates\nmay occur at any point in the future, or never. Handling application crash recovery safely\nrequires ",(0,a.kt)("a",{parentName:"li",href:"#consistency-with-foreign-databases"},"using ",(0,a.kt)("inlineCode",{parentName:"a"},"id"),"s to idempotently retry events"),".")),(0,a.kt)("h4",{id:"accounts"},(0,a.kt)("a",{parentName:"h4",href:"/reference/accounts"},"Accounts")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Accounts are immutable. They are never modified once they are successfully created (excluding\nbalance fields, which are modified by transfers)."),(0,a.kt)("li",{parentName:"ul"},"There is at most one ",(0,a.kt)("inlineCode",{parentName:"li"},"Account")," with a particular ",(0,a.kt)("a",{parentName:"li",href:"/reference/accounts#id"},(0,a.kt)("inlineCode",{parentName:"a"},"id")),"."),(0,a.kt)("li",{parentName:"ul"},"The sum of all accounts' ",(0,a.kt)("a",{parentName:"li",href:"/reference/accounts#debits_pending"},(0,a.kt)("inlineCode",{parentName:"a"},"debits_pending"))," equals the\nsum of all accounts' ",(0,a.kt)("a",{parentName:"li",href:"/reference/accounts#credits_pending"},(0,a.kt)("inlineCode",{parentName:"a"},"credits_pending")),"."),(0,a.kt)("li",{parentName:"ul"},"The sum of all accounts' ",(0,a.kt)("a",{parentName:"li",href:"/reference/accounts#debits_posted"},(0,a.kt)("inlineCode",{parentName:"a"},"debits_posted"))," equals the sum\nof all accounts' ",(0,a.kt)("a",{parentName:"li",href:"/reference/accounts#credits_posted"},(0,a.kt)("inlineCode",{parentName:"a"},"credits_posted")),".")),(0,a.kt)("h4",{id:"transfers"},(0,a.kt)("a",{parentName:"h4",href:"/reference/transfers"},"Transfers")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Transfers are immutable. They are never modified once they are successfully created."),(0,a.kt)("li",{parentName:"ul"},"There is at most one ",(0,a.kt)("inlineCode",{parentName:"li"},"Transfer")," with a particular ",(0,a.kt)("a",{parentName:"li",href:"/reference/transfers#id"},(0,a.kt)("inlineCode",{parentName:"a"},"id")),"."),(0,a.kt)("li",{parentName:"ul"},"A ",(0,a.kt)("a",{parentName:"li",href:"/design/two-phase-transfers#reserve-funds-pending-transfer"},"pending transfer")," resolves at most\nonce."),(0,a.kt)("li",{parentName:"ul"},"Transfer ",(0,a.kt)("a",{parentName:"li",href:"/reference/transfers#timeout"},"timeouts")," are deterministic, driven by the ",(0,a.kt)("a",{parentName:"li",href:"/design/time#why-tigerbeetle-manages-timestamps"},"cluster's\ntimestamp"),".")),(0,a.kt)("h3",{id:"reply-order"},"Reply Order"),(0,a.kt)("p",null,"Replies to a client session always arrive in order \u2014 a client session may have only one request\nin-flight, and clients ignore (duplicate) replies to their prior requests."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Requests are executed in the order they arrive at the cluster's primary."),(0,a.kt)("li",{parentName:"ul"},"Replies to different clients may arrive out of order.")),(0,a.kt)("h4",{id:"example"},"Example"),(0,a.kt)("p",null,"Consider two clients ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"B"),":"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Client ",(0,a.kt)("inlineCode",{parentName:"li"},"A")," sends request ",(0,a.kt)("inlineCode",{parentName:"li"},"A\u2081"),"."),(0,a.kt)("li",{parentName:"ol"},"Client ",(0,a.kt)("inlineCode",{parentName:"li"},"B")," sends request ",(0,a.kt)("inlineCode",{parentName:"li"},"B\u2081"),".")),(0,a.kt)("p",null,"Client ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," sent its request first, but requests ",(0,a.kt)("inlineCode",{parentName:"p"},"A\u2081")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"B\u2081")," may execute in either order \u2014\nwhichever arrives first at the primary will execute first."),(0,a.kt)("p",null,"In this diagram, the requests are delivered out of order \u2014 ",(0,a.kt)("inlineCode",{parentName:"p"},"B\u2081")," then ",(0,a.kt)("inlineCode",{parentName:"p"},"A\u2081"),":"),(0,a.kt)("mermaid",{value:"sequenceDiagram\n    autonumber\n    participant Client A\n    participant Client B\n    participant (Network)\n    participant Cluster\n    Client A->>(Network): A\u2081 (request)\n    Client B->>(Network): B\u2081 (request)\n    Note over (Network): Request A\u2081 is delayed by the network.\n    (Network)->>Cluster: B\u2081 (request)\n    (Network)->>Cluster: A\u2081 (request)\n    Cluster->>(Network): B\u2081 (reply)\n    Cluster->>(Network): A\u2081 (reply)\n    (Network)->>Client B: B\u2081(reply)\n    (Network)->>Client A: A\u2081 (reply)"}),(0,a.kt)("p",null,"Suppose instead ",(0,a.kt)("inlineCode",{parentName:"p"},"A\u2081")," arrives and executes before ",(0,a.kt)("inlineCode",{parentName:"p"},"B\u2081"),". The replies may be delivered in the same\norder (",(0,a.kt)("inlineCode",{parentName:"p"},"A\u2081")," then ",(0,a.kt)("inlineCode",{parentName:"p"},"B\u2081"),"), or they may be reordered, as shown below:"),(0,a.kt)("mermaid",{value:"sequenceDiagram\n    autonumber\n    participant Client A\n    participant Client B\n    participant (Network)\n    participant Cluster\n    Client A->>(Network): A\u2081 (request)\n    Client B->>(Network): B\u2081 (request)\n    (Network)->>Cluster: A\u2081 (request)\n    (Network)->>Cluster: B\u2081 (request)\n    Cluster->>(Network): A\u2081 (reply)\n    Cluster->>(Network): B\u2081 (reply)\n    Note over (Network): Reply A\u2081 is delayed by the network.\n    (Network)->>Client B: B\u2081(reply)\n    (Network)->>Client A: A\u2081 (reply)"}),(0,a.kt)("h3",{id:"retries"},"Retries"),(0,a.kt)("p",null,"A ",(0,a.kt)("a",{parentName:"p",href:"/design/client-sessions"},"client session")," will automatically retry a request until either:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the client receives a corresponding reply from the cluster, or"),(0,a.kt)("li",{parentName:"ul"},"the client is terminated.")),(0,a.kt)("p",null,"Unlike most database or RPC clients:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the TigerBeetle client will never time out"),(0,a.kt)("li",{parentName:"ul"},"the TigerBeetle client has no retry limits"),(0,a.kt)("li",{parentName:"ul"},"the TigerBeetle client does not surface network errors")),(0,a.kt)("p",null,"With TigerBeetle's strict consistency model, surfacing these errors at the client/application level\nwould be misleading. An error would imply that a request did not execute, when that is not known:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A request delayed by the network could execute after its timeout."),(0,a.kt)("li",{parentName:"ul"},"A reply delayed by the network could execute before its timeout.")),(0,a.kt)("h3",{id:"consistency-with-foreign-databases"},"Consistency with Foreign Databases"),(0,a.kt)("p",null,"TigerBeetle objects may correspond to objects in a foreign data store (e.g. another DBMS). Keeping\nmultiple data stores consistent (in sync) is subtle in the context of application process faults."),(0,a.kt)("p",null,"Object creation events are idempotent, but only the first attempt will return\n",(0,a.kt)("a",{parentName:"p",href:"/reference/operations/create_transfers#ok"},(0,a.kt)("inlineCode",{parentName:"a"},".ok")),", while all successive identical attempts\nreturn ",(0,a.kt)("a",{parentName:"p",href:"/reference/operations/create_transfers#exists"},(0,a.kt)("inlineCode",{parentName:"a"},".exists")),". The client may crash after\ncreating the object, but before receiving the ",(0,a.kt)("inlineCode",{parentName:"p"},".ok")," reply. Because the session resets, neither that\nclient nor any others will see the object's corresponding ",(0,a.kt)("inlineCode",{parentName:"p"},".ok")," result."),(0,a.kt)("p",null,"Therefore, to recover to the correct state after a crash, an application that synchronizes updates\nbetween multiple data stores must treat ",(0,a.kt)("inlineCode",{parentName:"p"},".exists")," as equivalent to ",(0,a.kt)("inlineCode",{parentName:"p"},".ok"),"."),(0,a.kt)("h4",{id:"example-1"},"Example"),(0,a.kt)("p",null,"Suppose that an application creates users within Postgres, and for each user a corresponding\n",(0,a.kt)("inlineCode",{parentName:"p"},"Account")," in the TigerBeetle cluster."),(0,a.kt)("p",null,"This scenario depicts the typical case:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Application"),": Create user ",(0,a.kt)("inlineCode",{parentName:"li"},"U\u2081")," in Postgres with ",(0,a.kt)("inlineCode",{parentName:"li"},"U\u2081.account_id = A\u2081")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"U\u2081.account_exists =\nfalse"),"."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Application"),': Send "create account" request ',(0,a.kt)("inlineCode",{parentName:"li"},"A\u2081")," to the cluster."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Cluster"),": Create ",(0,a.kt)("inlineCode",{parentName:"li"},"A\u2081"),"; reply ",(0,a.kt)("inlineCode",{parentName:"li"},"ok"),"."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Application"),": Receive reply ",(0,a.kt)("inlineCode",{parentName:"li"},"A\u2081: ok")," from the cluster."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Application"),": Set ",(0,a.kt)("inlineCode",{parentName:"li"},"U\u2081.account_exists = true"),".")),(0,a.kt)("p",null,"But suppose the application crashes and restarts immediately after sending its request (step 2):"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Application"),": Create user ",(0,a.kt)("inlineCode",{parentName:"li"},"U\u2081")," in Postgres with ",(0,a.kt)("inlineCode",{parentName:"li"},"U\u2081.account_id = A\u2081")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"U\u2081.account_exists =\nfalse"),"."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Application"),': Send "create account" request ',(0,a.kt)("inlineCode",{parentName:"li"},"A\u2081")," to the cluster."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Application"),": Crash. Restart."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Cluster"),": Create ",(0,a.kt)("inlineCode",{parentName:"li"},"A\u2081"),"; reply ",(0,a.kt)("inlineCode",{parentName:"li"},"ok")," \u2014 but the application session has reset, so this reply never\nreaches the application."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Application"),': Send "create account" request ',(0,a.kt)("inlineCode",{parentName:"li"},"A\u2081")," to the cluster. The request uses the same ID\nas in step 1."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Cluster"),": Create ",(0,a.kt)("inlineCode",{parentName:"li"},"A\u2081"),"; reply ",(0,a.kt)("inlineCode",{parentName:"li"},"exists"),"."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Application"),": Receive reply ",(0,a.kt)("inlineCode",{parentName:"li"},"A\u2081: exists")," from the cluster."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Application"),": Set ",(0,a.kt)("inlineCode",{parentName:"li"},"U\u2081.account_exists = true"),".")),(0,a.kt)("p",null,"In the second case, the application observes that the account is created by receiving ",(0,a.kt)("inlineCode",{parentName:"p"},".exists"),"\n(step 6) instead of ",(0,a.kt)("inlineCode",{parentName:"p"},".ok"),"."),(0,a.kt)("p",null,"Note that the retry (step 5) reused the same account ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," from the original request (step 2). We\nrecommend using the same ",(0,a.kt)("inlineCode",{parentName:"p"},"id"),', as opposed to generating a new one for each "create account" attempt,\nto avoid leaving orphaned accounts in TigerBeetle if the application were to restart before\nreceiving the ',(0,a.kt)("inlineCode",{parentName:"p"},".ok")," code."))}d.isMDXComponent=!0}}]);