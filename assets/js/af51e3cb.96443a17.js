"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5616],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),c=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(a),m=n,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||i;return a?r.createElement(h,o(o({ref:t},p),{},{components:a})):r.createElement(h,o({ref:t},p))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:n,o[1]=s;for(var c=2;c<i;c++)o[c]=a[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},654:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=a(7462),n=(a(7294),a(3905));const i={sidebar_position:3},o="Safety",s={unversionedId:"about/safety",id:"about/safety",title:"Safety",description:"TigerBeetle is designed to a higher safety standard than a general-purpose relational database such",source:"@site/pages/about/safety.md",sourceDirName:"about",slug:"/about/safety",permalink:"/about/safety",draft:!1,editUrl:"https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/about/safety.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Performance",permalink:"/about/performance"},next:{title:"Deterministic Simulation Testing",permalink:"/about/vopr"}},l={},c=[{value:"Fault Models",id:"fault-models",level:2},{value:"Storage Fault Model",id:"storage-fault-model",level:3},{value:"Network Fault Model",id:"network-fault-model",level:3},{value:"Memory Fault Model",id:"memory-fault-model",level:3},{value:"Processing Fault Model",id:"processing-fault-model",level:3},{value:"Is TigerBeetle ACID-compliant?",id:"is-tigerbeetle-acid-compliant",level:2},{value:"Atomicity",id:"atomicity",level:3},{value:"Consistency",id:"consistency",level:3},{value:"Isolation",id:"isolation",level:3},{value:"Durability",id:"durability",level:3},{value:"<code>io_uring</code> Security",id:"io_uring-security",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...a}=e;return(0,n.kt)(d,(0,r.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"safety"},"Safety"),(0,n.kt)("p",null,"TigerBeetle is designed to a higher safety standard than a general-purpose relational database such\nas MySQL or an in-memory database such as Redis:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Strict consistency, CRCs and crash safety are not enough.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TigerBeetle ",(0,n.kt)("strong",{parentName:"p"},"handles and recovers from Latent Sector Errors")," (e.g. at least\n",(0,n.kt)("a",{parentName:"p",href:"https://www.usenix.org/system/files/fast20-maneas.pdf"},"0.031% of SSD disks per year on average"),",\nand\n",(0,n.kt)("a",{parentName:"p",href:"https://www.usenix.org/legacy/events/fast08/tech/full_papers/bairavasundaram/bairavasundaram.pdf"},"1.4% of Enterprise HDD disks per year on average"),")\n",(0,n.kt)("strong",{parentName:"p"},"detects and repairs disk corruption or misdirected I/O where firmware reads/writes the wrong\nsector")," (e.g. at least\n",(0,n.kt)("a",{parentName:"p",href:"https://www.usenix.org/system/files/fast20-maneas.pdf"},"0.023% of SSD disks per year on average"),",\nand\n",(0,n.kt)("a",{parentName:"p",href:"https://www.usenix.org/legacy/events/fast08/tech/full_papers/bairavasundaram/bairavasundaram.pdf"},"0.466% of Nearline HDD disks per year on average"),"),\nand ",(0,n.kt)("strong",{parentName:"p"},"detects and repairs data tampering")," (on a minority of the cluster, as if it were\nnon-Byzantine corruption) with hash-chained checksums.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TigerBeetle ",(0,n.kt)("strong",{parentName:"p"},"uses Direct I/O by design")," to sidestep\n",(0,n.kt)("a",{parentName:"p",href:"https://www.usenix.org/system/files/atc20-rebello.pdf"},"cache coherency bugs in the kernel page cache"),"\nafter an EIO fsync error.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TigerBeetle ",(0,n.kt)("strong",{parentName:"p"},"exceeds the fsync durability of a single disk")," and the hardware of a single server\nbecause disk firmware can contain bugs and because single server systems fail.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TigerBeetle ",(0,n.kt)("strong",{parentName:"p"},"provides strict serializability"),", the gold standard of consistency, as a replicated\nstate machine, and as a cluster of TigerBeetle servers (called replicas), for optimal high\navailability and distributed fault-tolerance.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TigerBeetle ",(0,n.kt)("strong",{parentName:"p"},"performs synchronous replication")," to a quorum of backup TigerBeetle servers using\nthe pioneering ",(0,n.kt)("a",{parentName:"p",href:"http://pmg.csail.mit.edu/papers/vr-revisited.pdf"},"Viewstamped Replication")," and\nconsensus protocol for low-latency automated leader election and to eliminate the risk of\nsplit-brain associated with ad hoc manual failover systems.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TigerBeetle is \u201cfault-aware\u201d and ",(0,n.kt)("strong",{parentName:"p"},"recovers from local storage failures in the context of the\nglobal consensus protocol"),", providing\n",(0,n.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=fDY6Wi0GcPs"},"more safety than replicated state machines such as ZooKeeper and LogCabin"),".\nFor example, TigerBeetle can disentangle corruption in the middle of the committed journal (caused\nby bitrot) from torn writes at the end of the journal (caused by a power failure) to uphold\ndurability guarantees given for committed data and maximize availability.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TigerBeetle does not depend on synchronized system clocks, does not use leader leases, and\n",(0,n.kt)("strong",{parentName:"p"},"performs leader-based timestamping"),' so that your application can deal only with safe relative\nquantities of time with respect to transfer timeouts. To ensure that the leader\'s clock is within\nsafe bounds of "true time", TigerBeetle combines all the clocks in the cluster to create a\nfault-tolerant clock that we call\n',(0,n.kt)("a",{parentName:"p",href:"https://tigerbeetle.com/blog/2021-08-30-three-clocks-are-better-than-one"},'"cluster time"'),"."))),(0,n.kt)("h2",{id:"fault-models"},"Fault Models"),(0,n.kt)("p",null,"We adopt the following fault models with respect to storage, network, memory and processing:"),(0,n.kt)("h3",{id:"storage-fault-model"},"Storage Fault Model"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Disks experience data corruption with significant and material probability.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Disk firmware or hardware may cause writes to be misdirected and written to the wrong sector, or\nnot written at all, with low but nevertheless material probability.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Disk firmware or hardware may cause reads to be misdirected and read from the wrong sector, or not\nread at all, with low but nevertheless material probability.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Corruption does not always imply a system crash. Data may be corrupted at any time during its\nstorage lifecycle: before being written, while being written, after being written, and while being\nread.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Disk sector writes are not atomic. For example, an Advanced Format 4096 byte sector write to a\ndisk with an emulated logical sector size of 4096 bytes, but a physical sector size of 512 bytes\nis not atomic and would be split into 8 physical sector writes, which may or may not be atomic.\nTherefore, we do not depend on any sector atomicity guarantees from the disk.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"The Linux kernel page cache is not reliable and may misrepresent the state of data on disk after\nan EIO or latent sector error. See\n",(0,n.kt)("em",{parentName:"p"},(0,n.kt)("a",{parentName:"em",href:"https://www.usenix.org/system/files/atc20-rebello.pdf"},"Can Applications Recover from fsync Failures?")),"\nfrom the University of Wisconsin \u2013 Madison presented at the 2020 USENIX Annual Technical\nConference.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"File system metadata (such as a file's size) is unreliable and may change at any time.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Disk performance and read and write latencies can sometimes be volatile, causing latency spikes on\nthe order of seconds. A slow disk does not always indicate a failing disk, and a slow disk may\nreturn to median performance levels \u2014 for example, an SSD undergoing garbage collection."))),(0,n.kt)("h3",{id:"network-fault-model"},"Network Fault Model"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Messages may be lost.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Messages may be corrupted.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Messages may be delayed.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Messages may be replayed.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TCP checksums are inadequate to prevent checksum collisions.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Network performance may be asymmetrical for the upload and download paths."))),(0,n.kt)("h3",{id:"memory-fault-model"},"Memory Fault Model"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Memory protected with error-correcting codes is sufficient for our purpose. We make no further\neffort to protect against memory faults.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Non-ECC memory is not recommended by TigerBeetle."))),(0,n.kt)("h3",{id:"processing-fault-model"},"Processing Fault Model"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"The system may crash at any time.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"The system may freeze process execution for minutes or hours at a time, for example, during a VM\nmigration.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"The system clock may jump backwards or forwards in time, at any time.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"NTP can help, but we cannot depend on NTP for strict serializability.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"NTP may stop working because of a network partition, which may not impact TigerBeetle. We,\ntherefore, need to detect when a TigerBeetle cluster's clocks are not being synchronized by NTP so\nthat financial transaction timestamps are accurate and within the operator's tolerance for error."))),(0,n.kt)("h2",{id:"is-tigerbeetle-acid-compliant"},"Is TigerBeetle ACID-compliant?"),(0,n.kt)("p",null,"Yes. Let's discuss each part:"),(0,n.kt)("h3",{id:"atomicity"},"Atomicity"),(0,n.kt)("p",null,"As part of replication, each operation is durably stored in at least a quorum of replicas'\nWrite-Ahead Logs (WAL) before the primary will acknowledge the operation as committed. WAL entries\nare executed through the state machine business logic and the resulting state changes are stored in\nTigerBeetle's LSM-Forest local storage engine."),(0,n.kt)("p",null,"The WAL is what allows TigerBeetle to achieve atomicity and durability since the WAL is the source\nof truth. If TigerBeetle crashes, the WAL is replayed at startup from the last checkpoint on disk."),(0,n.kt)("p",null,"However, financial atomicity goes further than this: events and transfers can be linked when created\nso they all succeed or fail together."),(0,n.kt)("h3",{id:"consistency"},"Consistency"),(0,n.kt)("p",null,"TigerBeetle guarantees strict serializability. And at the cluster level, stale reads are not\npossible since all operations (not only writes, but also reads) go through the global consensus\nprotocol."),(0,n.kt)("p",null,"However, financial consistency requires more than this. TigerBeetle exposes a double-entry\naccounting API to guarantee that money cannot be created or destroyed, but only transferred from one\naccount to another. And transfer history is immutable."),(0,n.kt)("h3",{id:"isolation"},"Isolation"),(0,n.kt)("p",null,"All client requests (and all events within a client request batch) are executed with the highest\nlevel of isolation, serially through the state machine, one after another, before the next operation\nbegins. Counterintuitively, the use of batching and serial execution means that TigerBeetle can also\nprovide this level of isolation optimally, without the cost of locks for all the individual events\nwithin a batch."),(0,n.kt)("h3",{id:"durability"},"Durability"),(0,n.kt)("p",null,"Up until 2018, traditional DBMS durability has focused on the Crash Consistency Model, however,\nFsyncgate and\n",(0,n.kt)("a",{parentName:"p",href:"https://www.usenix.org/conference/fast18/presentation/alagappan"},"Protocol Aware Recovery")," have\nshown that this model can lead to real data loss for users in the wild. TigerBeetle therefore adopts\nan explicit storage fault model, which we then verify and test with incredible levels of corruption,\nsomething which few distributed systems historically were designed to handle. Our emphasis on\nprotecting Durability is what sets TigerBeetle apart, not only as a ledger but as a DBMS."),(0,n.kt)("p",null,"However, absolute durability is impossible, because all hardware can ultimately fail. Data we write\ntoday might not be available tomorrow. TigerBeetle embraces limited disk reliability and maximizes\ndata durability in spite of imperfect disks. We actively work against such entropy by taking\nadvantage of cluster-wide storage. A record would need to get corrupted on all replicas in a cluster\nto get lost, and even in that case the system would safely halt."),(0,n.kt)("h2",{id:"io_uring-security"},(0,n.kt)("inlineCode",{parentName:"h2"},"io_uring")," Security"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"io_uring")," is a relatively new part of the Linux kernel (support for it was added in version 5.1,\nwhich was released in May 2019). Since then, many kernel exploits have been found related to\n",(0,n.kt)("inlineCode",{parentName:"p"},"io_uring")," and in 2023\n",(0,n.kt)("a",{parentName:"p",href:"https://security.googleblog.com/2023/06/learnings-from-kctf-vrps-42-linux.html"},"Google announced"),"\nthat they were disabling it in ChromeOS, for Android apps, and on Google production servers."),(0,n.kt)("p",null,"Google's post is primarily about how they secure operating systems and web servers that handle\nhostile user content. In the Google blog post, they specifically note:"),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"we currently consider it safe only for use by trusted components")),(0,n.kt)("p",null,"As a financial system of record, TigerBeetle is a trusted component and it should be running in a\ntrusted environment."),(0,n.kt)("p",null,"Furthermore, TigerBeetle only uses 128-byte ",(0,n.kt)("a",{parentName:"p",href:"/reference/account"},(0,n.kt)("inlineCode",{parentName:"a"},"Account"),"s")," and\n",(0,n.kt)("a",{parentName:"p",href:"/reference/transfer"},(0,n.kt)("inlineCode",{parentName:"a"},"Transfer"),"s")," with pure integer fields. TigerBeetle has no\n(de)serialization and does not take user-generated strings, which significantly constrains the\nattack surface."),(0,n.kt)("p",null,"We are confident that ",(0,n.kt)("inlineCode",{parentName:"p"},"io_uring")," is the safest (and most performant) way for TigerBeetle to handle\nasync I/O. It is significantly easier for the kernel to implement this correctly than for us to\ninclude a userspace multithreaded thread pool (for example, as libuv does)."))}u.isMDXComponent=!0}}]);