"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7042],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>f});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),c=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(r),d=n,f=p["".concat(l,".").concat(d)]||p[d]||m[d]||o;return r?a.createElement(f,i(i({ref:t},u),{},{components:r})):a.createElement(f,i({ref:t},u))}));function f(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:n,i[1]=s;for(var c=2;c<o;c++)i[c]=r[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},5482:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=r(7462),n=(r(7294),r(3905));const o={sidebar_position:2},i="Performance",s={unversionedId:"about/performance",id:"about/performance",title:"Performance",description:"TigerBeetle provides more performance than a general-purpose relational database such as MySQL or an",source:"@site/pages/about/performance.md",sourceDirName:"about",slug:"/about/performance",permalink:"/about/performance",draft:!1,editUrl:"https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/about/performance.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Built for OLTP",permalink:"/about/oltp"},next:{title:"Safety",permalink:"/about/safety"}},l={},c=[{value:"Single-Core By Design",id:"single-core-by-design",level:2}],u={toc:c},p="wrapper";function m(e){let{components:t,...r}=e;return(0,n.kt)(p,(0,a.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"performance"},"Performance"),(0,n.kt)("p",null,"TigerBeetle provides more performance than a general-purpose relational database such as MySQL or an\nin-memory database such as Redis:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TigerBeetle ",(0,n.kt)("strong",{parentName:"p"},"uses small, simple fixed-size data structures")," (accounts and transfers) and a\ntightly scoped domain.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TigerBeetle ",(0,n.kt)("strong",{parentName:"p"},"uses multiple Log-Structured Merge (LSM) Trees")," for storing objects and indices.\nThis data structure is highly optimized for write-heavy workloads like Online Transaction\nProcessing (OLTP). TigerBeetle squeezes even more performance out of LSM trees by using multiple\ntrees, each storing separate types of homogeneous data.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TigerBeetle ",(0,n.kt)("strong",{parentName:"p"},"performs all balance tracking logic in the database"),". This is a paradigm shift\nwhere we move the code once to the data, not the data back and forth to the code in the critical\npath. This eliminates the need for complex caching logic outside the database. The \u201cAccounting\u201d\nbusiness logic is built into TigerBeetle so that you can ",(0,n.kt)("strong",{parentName:"p"},"keep your application layer simple and\ncompletely stateless"),".")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TigerBeetle ",(0,n.kt)("strong",{parentName:"p"},"supports batching by design"),". You can batch all the transfer prepares or commits\nthat you receive in a fixed 10ms window (or in a dynamic 1ms through 10ms window according to\nload) and then send them all in a single network request to the database. This enables\nlow-overhead networking, large sequential disk write patterns and amortized fsync and consensus\nacross hundreds and thousands of transfers."))),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"Everything is a batch. It's your choice whether a batch contains 100 transfers or 10,000 transfers\nbut our measurements show that ",(0,n.kt)("strong",{parentName:"p"},"latency is ",(0,n.kt)("em",{parentName:"strong"},"less")," where batch sizes are larger, thanks to\nLittle's Law")," (e.g. 50ms for a batch of a hundred transfers vs 20ms for a batch of ten thousand\ntransfers). TigerBeetle is able to amortize the cost of I/O to achieve lower latency, even for\nfairly large batch sizes, by eliminating the cost of queueing delay incurred by small batches.")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"If your system is not under load, TigerBeetle also ",(0,n.kt)("strong",{parentName:"p"},"optimizes the latency of small batches"),".\nAfter copying from the kernel's TCP receive buffer (TigerBeetle does not do user-space TCP),\nTigerBeetle ",(0,n.kt)("strong",{parentName:"p"},"does zero-copy Direct I/O")," from network protocol to disk, and then to state machine\nand back, to reduce memory pressure and L1-L3 cache pollution.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TigerBeetle ",(0,n.kt)("strong",{parentName:"p"},"uses io_uring for zero-syscall networking and storage I/O"),". The cost of a syscall\nin terms of context switches adds up quickly for a few thousand transfers. (You can read about the\nsecurity of using io_uring ",(0,n.kt)("a",{parentName:"p",href:"/about/safety#io_uring-security"},"here"),".)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TigerBeetle ",(0,n.kt)("strong",{parentName:"p"},"does zero-deserialization")," by using fixed-size data structures that are optimized\nfor cache line alignment to ",(0,n.kt)("strong",{parentName:"p"},"minimize L1-L3 cache misses"),".")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"TigerBeetle ",(0,n.kt)("strong",{parentName:"p"},"takes advantage of Heidi Howard's Flexible Quorums")," to reduce the cost of\n",(0,n.kt)("strong",{parentName:"p"},"synchronous replication to one (or two) remote replicas at most")," (in addition to the leader)\nwith ",(0,n.kt)("strong",{parentName:"p"},"asynchronous replication")," between the remaining followers. This improves write\navailability without sacrificing strict serializability or durability. This also reduces server\ndeployment cost by as much as 20% because a 4-node cluster with Flexible Quorums can now provide\nthe same ",(0,n.kt)("inlineCode",{parentName:"p"},"f=2")," guarantee for the replication quorum as a 5-node cluster."))),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},(0,n.kt)("a",{parentName:"p",href:"https://www.microsoft.com/en-us/research/wp-content/uploads/2017/06/paper-1.pdf"},'"The major availability breakdowns and performance anomalies we see in cloud environments tend to\nbe caused by subtle underlying faults, i.e. gray failure (slowly failing hardware) rather than\nfail-stop\nfailure."'))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"TigerBeetle ",(0,n.kt)("strong",{parentName:"li"},"routes around transient gray failure latency spikes"),'. For example, if a disk write\nthat typically takes 4ms starts taking 4 seconds because the disk is slowly failing, TigerBeetle\nwill use cluster redundancy to mask the gray failure automatically without the user seeing any\n4-second latency spike. This is a relatively new performance technique in the literature known as\n"tail tolerance".')),(0,n.kt)("h2",{id:"single-core-by-design"},"Single-Core By Design"),(0,n.kt)("p",null,"TigerBeetle uses a single core by design and uses a single leader node to process events. Adding\nmore nodes can therefore increase reliability but not throughput."),(0,n.kt)("p",null,"For a high-performance database, this may seem like an unusual choice. However, sharding in\nfinancial databases is notoriously difficult and contention issues often negate the would-be\nbenefits. Specifically, a small number of hot accounts are often involved in a large proportion of\nthe transactions so the shards responsible for those accounts become bottlenecks."),(0,n.kt)("p",null,"For more details on when single-threaded implementations of algorithms outperform multi-threaded\nimplementations, see ",(0,n.kt)("a",{parentName:"p",href:"https://www.usenix.org/system/files/conference/hotos15/hotos15-paper-mcsherry.pdf"},'"Scalability! But at what\nCOST?'),"."))}m.isMDXComponent=!0}}]);