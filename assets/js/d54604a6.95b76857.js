"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8831],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),c=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=c(e.components);return a.createElement(o.Provider,{value:t},e.children)},m="mdxType",k={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),m=c(n),h=r,u=m["".concat(o,".").concat(h)]||m[h]||k[h]||i;return n?a.createElement(u,l(l({ref:t},s),{},{components:n})):a.createElement(u,l({ref:t},s))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=h;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p[m]="string"==typeof e?e:r,l[1]=p;for(var c=2;c<i;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3791:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>k,frontMatter:()=>i,metadata:()=>p,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:4},l="State Sync",p={unversionedId:"internals/sync",id:"internals/sync",title:"State Sync",description:"State sync synchronizes the state of a lagging replica with the healthy cluster.",source:"@site/pages/internals/sync.md",sourceDirName:"internals",slug:"/internals/sync",permalink:"/internals/sync",draft:!1,editUrl:"https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/internals/sync.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"LSM",permalink:"/internals/lsm"},next:{title:"Testing",permalink:"/internals/testing"}},o={},c=[{value:"Glossary",id:"glossary",level:2},{value:"Algorithm",id:"algorithm",level:2},{value:"0: Scenarios",id:"0-scenarios",level:3},{value:"1: Triggers",id:"1-triggers",level:3},{value:"6: Request Superblock Checkpoint State",id:"6-request-superblock-checkpoint-state",level:3},{value:"Concepts",id:"concepts",level:2},{value:"Syncing Replica",id:"syncing-replica",level:3},{value:"Syncing Replicas write prepares to their WAL.",id:"syncing-replicas-write-prepares-to-their-wal",level:4},{value:"Syncing Replicas don&#39;t ack prepares.",id:"syncing-replicas-dont-ack-prepares",level:4},{value:"Checkpoint Identifier",id:"checkpoint-identifier",level:3},{value:"Sync Target",id:"sync-target",level:3},{value:"Storage Determinism",id:"storage-determinism",level:3}],s={toc:c},m="wrapper";function k(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"state-sync"},"State Sync"),(0,r.kt)("p",null,"State sync synchronizes the state of a lagging replica with the healthy cluster."),(0,r.kt)("p",null,"State sync is used when when a lagging replica's log no longer intersects with the cluster's current log \u2014\n",(0,r.kt)("a",{parentName:"p",href:"/internals/vsr#protocol-repair-wal"},"WAL repair")," cannot catch the replica up."),(0,r.kt)("p",null,'(VRR refers to state sync as "state transfer", but we already have ',(0,r.kt)("a",{parentName:"p",href:"/reference/transfers"},"transfers")," elsewhere.)"),(0,r.kt)("p",null,'In the context of state sync, "state" refers to:'),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"the superblock ",(0,r.kt)("inlineCode",{parentName:"li"},"vsr_state.checkpoint")),(0,r.kt)("li",{parentName:"ol"},"the grid (manifest, free set, and client sessions blocks)"),(0,r.kt)("li",{parentName:"ol"},"the grid (LSM table data; acquired blocks only)"),(0,r.kt)("li",{parentName:"ol"},"client replies")),(0,r.kt)("p",null,"State sync consists of four protocols:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/internals/vsr#protocol-sync-superblock"},"Sync Superblock")," (syncs 1)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/internals/vsr#protocol-repair-grid"},"Repair Grid")," (syncs 2)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/internals/vsr#protocol-sync-forest"},"Sync Forest")," (syncs 3)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/internals/vsr#protocol-sync-client-replies"},"Sync Client Replies")," (syncs 4)")),(0,r.kt)("p",null,"The target of superblock-sync is the latest checkpoint of the healthy cluster.\nWhen we catch up to the latest checkpoint (or very close to it), then we can transition back to a healthy state."),(0,r.kt)("h2",{id:"glossary"},"Glossary"),(0,r.kt)("p",null,"Replica roles:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"syncing replica"),": A replica performing superblock-sync. (Any step within ",(0,r.kt)("em",{parentName:"li"},"1"),"-",(0,r.kt)("em",{parentName:"li"},"10")," of the ",(0,r.kt)("a",{parentName:"li",href:"#algorithm"},"sync algorithm"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"healthy replica"),": A replica ",(0,r.kt)("em",{parentName:"li"},"not")," performing superblock-sync \u2014 part of the active cluster."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"divergent replica"),": A replica with a checkpoint that is (and can never be) canonical.")),(0,r.kt)("p",null,"Checkpoints:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#checkpoint-identifier"},(0,r.kt)("em",{parentName:"a"},"checkpoint id"),"/",(0,r.kt)("em",{parentName:"a"},"checkpoint identifier")),": Uniquely identifies a particular checkpoint reproducibly across replicas."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#sync-target"},(0,r.kt)("em",{parentName:"a"},"sync target")),": The checkpoint identifier of the target of superblock-sync.")),(0,r.kt)("h2",{id:"algorithm"},"Algorithm"),(0,r.kt)("ol",{start:0},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#0-scenarios"},"Sync is needed"),"."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#1-triggers"},"Trigger sync"),"."),(0,r.kt)("li",{parentName:"ol"},"Wait for non-grid commit operation to finish."),(0,r.kt)("li",{parentName:"ol"},"Wait for grid IO to finish. (See ",(0,r.kt)("inlineCode",{parentName:"li"},"Grid.cancel()"),".)"),(0,r.kt)("li",{parentName:"ol"},"Wait for a usable sync target to arrive. (Usually we already have one.)"),(0,r.kt)("li",{parentName:"ol"},"Begin ",(0,r.kt)("a",{parentName:"li",href:"/internals/vsr#protocol-sync-superblock"},"sync-superblock protocol"),"."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#6-request-superblock-checkpoint-state"},"Request superblock checkpoint state"),"."),(0,r.kt)("li",{parentName:"ol"},"Update the superblock headers with:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Bump ",(0,r.kt)("inlineCode",{parentName:"li"},"vsr_state.checkpoint.header")," to the sync target header."),(0,r.kt)("li",{parentName:"ul"},"Bump ",(0,r.kt)("inlineCode",{parentName:"li"},"vsr_state.checkpoint.parent_checkpoint_id")," to the checkpoint id that is previous to our sync target (i.e. it isn't ",(0,r.kt)("em",{parentName:"li"},"our")," previous checkpoint)."),(0,r.kt)("li",{parentName:"ul"},"Bump ",(0,r.kt)("inlineCode",{parentName:"li"},"replica.commit_min"),". (If ",(0,r.kt)("inlineCode",{parentName:"li"},"replica.commit_min")," exceeds ",(0,r.kt)("inlineCode",{parentName:"li"},"replica.op"),", transition to ",(0,r.kt)("inlineCode",{parentName:"li"},"status=recovering_head"),")."),(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"vsr_state.sync_op_min")," to the minimum op which has not been repaired."),(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"vsr_state.sync_op_max")," to the maximum op which has not been repaired."))),(0,r.kt)("li",{parentName:"ol"},"Sync-superblock protocol is done."),(0,r.kt)("li",{parentName:"ol"},"Repair ",(0,r.kt)("a",{parentName:"li",href:"/internals/vsr#protocol-sync-client-replies"},"replies"),", ",(0,r.kt)("a",{parentName:"li",href:"/internals/vsr#protocol-repair-grid"},"free set, client sessions, and manifest blocks"),", and ",(0,r.kt)("a",{parentName:"li",href:"/internals/vsr#protocol-sync-forest"},"table blocks")," that were created within the ",(0,r.kt)("inlineCode",{parentName:"li"},"sync_op_{min,max}")," range."),(0,r.kt)("li",{parentName:"ol"},"Update the superblock with:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"vsr_state.sync_op_min = 0")),(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"vsr_state.sync_op_max = 0"))))),(0,r.kt)("p",null,"If a newer sync target is discovered during steps ",(0,r.kt)("em",{parentName:"p"},"5"),"-",(0,r.kt)("em",{parentName:"p"},"6")," or ",(0,r.kt)("em",{parentName:"p"},"9"),", go to step ",(0,r.kt)("em",{parentName:"p"},"4"),"."),(0,r.kt)("p",null,"If the replica starts up with ",(0,r.kt)("inlineCode",{parentName:"p"},"vsr_state.sync_op_max \u2260 0"),", go to step ",(0,r.kt)("em",{parentName:"p"},"9"),"."),(0,r.kt)("h3",{id:"0-scenarios"},"0: Scenarios"),(0,r.kt)("p",null,"Scenarios requiring state sync:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A replica was down/partitioned/slow for a while and the rest of the cluster moved on.\nThe lagging replica is too far behind to catch up via WAL repair."),(0,r.kt)("li",{parentName:"ol"},"A replica was just formatted and is being added to the cluster (i.e. via ",(0,r.kt)("a",{parentName:"li",href:"/internals/vsr#protocol-reconfiguration"},"reconfiguration"),").\nThe new replica is too far behind to catch up via WAL repair.")),(0,r.kt)("p",null,"Causes of number 3:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A storage determinism bug."),(0,r.kt)("li",{parentName:"ul"},"An upgraded replica (e.g. a canary) running a different version of the code from the remainder of the cluster, which unexpectedly changes its history.\n(The change either has a bug or should have been gated behind a feature flag.)")),(0,r.kt)("h3",{id:"1-triggers"},"1: Triggers"),(0,r.kt)("p",null,"State sync is initially triggered by any of the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The replica receives a SV which indicates that it has lagged so far behind the cluster that its log cannot possibly intersect."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"repair_sync_timeout")," fires, and:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"a WAL or grid repair is in progress and,"),(0,r.kt)("li",{parentName:"ul"},"the replica's checkpoint is lagging behind the cluster's (far enough that the repair may never complete).")))),(0,r.kt)("h3",{id:"6-request-superblock-checkpoint-state"},"6: Request Superblock Checkpoint State"),(0,r.kt)("p",null,"The syncing replica sends ",(0,r.kt)("inlineCode",{parentName:"p"},"command=request_sync_checkpoint")," messages (with the sync target identifier attached to each) until it receives a ",(0,r.kt)("inlineCode",{parentName:"p"},"command=sync_checkpoint")," with a matching checkpoint identifier."),(0,r.kt)("h2",{id:"concepts"},"Concepts"),(0,r.kt)("h3",{id:"syncing-replica"},"Syncing Replica"),(0,r.kt)("p",null,"Syncing replicas may:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#syncing-replicas-write-prepares-to-their-wal"},"write prepares to their WAL")),(0,r.kt)("li",{parentName:"ul"},"assist with grid repair"),(0,r.kt)("li",{parentName:"ul"},"join new views"),(0,r.kt)("li",{parentName:"ul"},"send a ",(0,r.kt)("inlineCode",{parentName:"li"},"do_view_change"))),(0,r.kt)("p",null,"Syncing replicas must not:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#syncing-replicas-dont-ack-prepares"},"ack")),(0,r.kt)("li",{parentName:"ul"},"commit prepares"),(0,r.kt)("li",{parentName:"ul"},"be a primary")),(0,r.kt)("h4",{id:"syncing-replicas-write-prepares-to-their-wal"},"Syncing Replicas write prepares to their WAL."),(0,r.kt)("p",null,"When the replica completes superblock-sync, an up-to-date WAL and journal allow it to quickly catch up (i.e. commit) to the current cluster state."),(0,r.kt)("h4",{id:"syncing-replicas-dont-ack-prepares"},"Syncing Replicas don't ack prepares."),(0,r.kt)("p",null,"If syncing replicas ",(0,r.kt)("em",{parentName:"p"},"did")," ack prepares:"),(0,r.kt)("p",null,"Consider a cluster of 3 replicas:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("em",{parentName:"li"},"primary"),","),(0,r.kt)("li",{parentName:"ul"},"a ",(0,r.kt)("em",{parentName:"li"},"normal backup"),", and"),(0,r.kt)("li",{parentName:"ul"},"a ",(0,r.kt)("em",{parentName:"li"},"syncing backup"),".")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("em",{parentName:"li"},"Primary")," prepares many ops..."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("em",{parentName:"li"},"Syncing backup")," prepares and acknowledges all of those messages."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("em",{parentName:"li"},"Normal backup")," is partitioned \u2014 its not seeing any of these prepares."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("em",{parentName:"li"},"Primary")," is receiving ",(0,r.kt)("inlineCode",{parentName:"li"},"prepare_ok"),"s from the ",(0,r.kt)("em",{parentName:"li"},"syncing backup"),", so it is committing."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("em",{parentName:"li"},"Primary")," eventually checkpoints."),(0,r.kt)("li",{parentName:"ol"},"(This cycle repeats \u2014 ",(0,r.kt)("em",{parentName:"li"},"primary")," keeps preparing/committing, ",(0,r.kt)("em",{parentName:"li"},"syncing backup")," keeps preparing, and ",(0,r.kt)("em",{parentName:"li"},"normal backup")," is still partitioned.)")),(0,r.kt)("p",null,"But now ",(0,r.kt)("em",{parentName:"p"},"primary")," is so far ahead that the ",(0,r.kt)("em",{parentName:"p"},"normal backup")," needs to sync!\nHaving 2/3 replicas syncing means that a single grid-block corruption on the primary could make the cluster permanently unavailable."),(0,r.kt)("h3",{id:"checkpoint-identifier"},"Checkpoint Identifier"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"checkpoint id")," is a hash of the superblock ",(0,r.kt)("inlineCode",{parentName:"p"},"CheckpointState"),"."),(0,r.kt)("p",null,"A checkpoint identifier is attached to the following message types:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"command=commit"),": Current checkpoint identifier of sender."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"command=ping"),": Current checkpoint identifier of sender."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"command=prepare"),": The attached checkpoint id is the checkpoint id during which the corresponding prepare was originally prepared."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"command=prepare_ok"),": The attached checkpoint id is the checkpoint id during which the corresponding prepare was originally prepared."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"command=request_sync_checkpoint"),": Requested checkpoint identifier."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"command=sync_checkpoint"),": Current checkpoint identifier of sender.")),(0,r.kt)("h3",{id:"sync-target"},"Sync Target"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"sync target")," is the ",(0,r.kt)("a",{parentName:"p",href:"#checkpoint-identifier"},"checkpoint identifier")," of the checkpoint that the superblock-sync is syncing towards."),(0,r.kt)("p",null,"Not all checkpoint identifiers are valid sync targets."),(0,r.kt)("p",null,"Every sync target ",(0,r.kt)("strong",{parentName:"p"},"must"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"have an op greater than the syncing replica's current checkpoint op."),(0,r.kt)("li",{parentName:"ul"},"either:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"be committed atop \u2013 i.e. the syncing replica can sync to ",(0,r.kt)("inlineCode",{parentName:"li"},"healthy_replica.checkpoint_op")," when ",(0,r.kt)("inlineCode",{parentName:"li"},"trigger_for_checkpoint(healthy_replica.checkpoint_op) < healthy_replica.commit_min")," \u2013 ensuring that the checkpoint has been reached by a quorum of replicas, or"),(0,r.kt)("li",{parentName:"ul"},"be more than 1 checkpoint ahead of our current checkpoint.")))),(0,r.kt)("h3",{id:"storage-determinism"},"Storage Determinism"),(0,r.kt)("p",null,"When everything works, storage is deterministic.\nIf non-determinism is detected (via checkpoint id mismatches) the replica which detects the mismatch will panic.\nThis scenario should prompt operator investigation and manual intervention."))}k.isMDXComponent=!0}}]);