"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7736],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=c(n),p=r,h=u["".concat(l,".").concat(p)]||u[p]||f[p]||s;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[u]="string"==typeof e?e:r,i[1]=o;for(var c=2;c<s;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},6758:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>f,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const s={title:"Java"},i=void 0,o={unversionedId:"clients/java",id:"clients/java",title:"Java",description:"The TigerBeetle client for Java.",source:"@site/pages/clients/java.md",sourceDirName:"clients",slug:"/clients/java",permalink:"/clients/java",draft:!1,editUrl:"https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/clients/java.md",tags:[],version:"current",frontMatter:{title:"Java"},sidebar:"tutorialSidebar",previous:{title:"Go",permalink:"/clients/go"},next:{title:"Node.js",permalink:"/clients/node"}},l={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Setup",id:"setup",level:2},{value:"Sample projects",id:"sample-projects",level:2},{value:"Creating a Client",id:"creating-a-client",level:2},{value:"Creating Accounts",id:"creating-accounts",level:2},{value:"Account Flags",id:"account-flags",level:3},{value:"Response and Errors",id:"response-and-errors",level:3},{value:"Account Lookup",id:"account-lookup",level:2},{value:"Create Transfers",id:"create-transfers",level:2},{value:"Response and Errors",id:"response-and-errors-1",level:3},{value:"Batching",id:"batching",level:2},{value:"Queues and Workers",id:"queues-and-workers",level:3},{value:"Transfer Flags",id:"transfer-flags",level:2},{value:"Two-Phase Transfers",id:"two-phase-transfers",level:3},{value:"Post a Pending Transfer",id:"post-a-pending-transfer",level:4},{value:"Void a Pending Transfer",id:"void-a-pending-transfer",level:4},{value:"Transfer Lookup",id:"transfer-lookup",level:2},{value:"Get Account Transfers",id:"get-account-transfers",level:2},{value:"Get Account Balances",id:"get-account-balances",level:2},{value:"Query Accounts",id:"query-accounts",level:2},{value:"Query Transfers",id:"query-transfers",level:2},{value:"Linked Events",id:"linked-events",level:2},{value:"Imported Events",id:"imported-events",level:2}],d={toc:c},u="wrapper";function f(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"tigerbeetle-java"},"tigerbeetle-java"),(0,r.kt)("p",null,"The TigerBeetle client for Java."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://javadoc.io/doc/com.tigerbeetle/tigerbeetle-java"},(0,r.kt)("img",{parentName:"a",src:"https://javadoc.io/badge2/com.tigerbeetle/tigerbeetle-java/javadoc.svg",alt:"javadoc"}))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://central.sonatype.com/namespace/com.tigerbeetle"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/maven-central/v/com.tigerbeetle/tigerbeetle-java",alt:"maven-central"}))),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("p",null,"Linux >= 5.6 is the only production environment we\nsupport. But for ease of development we also support macOS and Windows."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Java >= 11"),(0,r.kt)("li",{parentName:"ul"},"Maven >= 3.6 (not strictly necessary but it's what our guides assume)")),(0,r.kt)("h2",{id:"setup"},"Setup"),(0,r.kt)("p",null,"First, create a directory for your project and ",(0,r.kt)("inlineCode",{parentName:"p"},"cd")," into the directory."),(0,r.kt)("p",null,"Then create ",(0,r.kt)("inlineCode",{parentName:"p"},"pom.xml")," and copy this into it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},'<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.tigerbeetle</groupId>\n  <artifactId>samples</artifactId>\n  <version>1.0-SNAPSHOT</version>\n\n  <properties>\n    <maven.compiler.source>11</maven.compiler.source>\n    <maven.compiler.target>11</maven.compiler.target>\n  </properties>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.8.1</version>\n        <configuration>\n          <compilerArgs>\n            <arg>-Xlint:all,-options,-path</arg>\n          </compilerArgs>\n        </configuration>\n      </plugin>\n\n      <plugin>\n        <groupId>org.codehaus.mojo</groupId>\n        <artifactId>exec-maven-plugin</artifactId>\n        <version>1.6.0</version>\n        <configuration>\n          <mainClass>com.tigerbeetle.samples.Main</mainClass>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n\n  <dependencies>\n    <dependency>\n      <groupId>com.tigerbeetle</groupId>\n      <artifactId>tigerbeetle-java</artifactId>\n      \x3c!-- Grab the latest commit from: https://repo1.maven.org/maven2/com/tigerbeetle/tigerbeetle-java/maven-metadata.xml --\x3e\n      <version>0.0.1-3431</version>\n    </dependency>\n  </dependencies>\n</project>\n')),(0,r.kt)("p",null,"Then, install the TigerBeetle client:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"mvn install\n")),(0,r.kt)("p",null,"Now, create ",(0,r.kt)("inlineCode",{parentName:"p"},"src/main/java/Main.java")," and copy this into it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import com.tigerbeetle.*;\n\npublic final class Main {\n    public static void main(String[] args) throws Exception {\n        System.out.println("Import ok!");\n    }\n}\n')),(0,r.kt)("p",null,"Finally, build and run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"mvn exec:java\n")),(0,r.kt)("p",null,"Now that all prerequisites and dependencies are correctly set\nup, let's dig into using TigerBeetle."),(0,r.kt)("h2",{id:"sample-projects"},"Sample projects"),(0,r.kt)("p",null,"This document is primarily a reference guide to\nthe client. Below are various sample projects demonstrating\nfeatures of TigerBeetle."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/tigerbeetle/tigerbeetle/blob/main/src/clients/java/samples/basic/"},"Basic"),": Create two accounts and transfer an amount between them."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/tigerbeetle/tigerbeetle/blob/main/src/clients/java/samples/two-phase/"},"Two-Phase Transfer"),": Create two accounts and start a pending transfer between\nthem, then post the transfer."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/tigerbeetle/tigerbeetle/blob/main/src/clients/java/samples/two-phase-many/"},"Many Two-Phase Transfers"),": Create two accounts and start a number of pending transfer\nbetween them, posting and voiding alternating transfers.")),(0,r.kt)("h2",{id:"creating-a-client"},"Creating a Client"),(0,r.kt)("p",null,"A client is created with a cluster ID and replica\naddresses for all replicas in the cluster. The cluster\nID and replica addresses are both chosen by the system that\nstarts the TigerBeetle cluster."),(0,r.kt)("p",null,"Clients are thread-safe and a single instance should be shared\nbetween multiple concurrent tasks."),(0,r.kt)("p",null,"Multiple clients are useful when connecting to more than\none TigerBeetle cluster."),(0,r.kt)("p",null,"In this example the cluster ID is ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," and there is one\nreplica. The address is read from the ",(0,r.kt)("inlineCode",{parentName:"p"},"TB_ADDRESS"),"\nenvironment variable and defaults to port ",(0,r.kt)("inlineCode",{parentName:"p"},"3000"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'String replicaAddress = System.getenv("TB_ADDRESS");\nbyte[] clusterID = UInt128.asBytes(0);\nString[] replicaAddresses = new String[] {replicaAddress == null ? "3000" : replicaAddress};\ntry (var client = new Client(clusterID, replicaAddresses)) {\n    // Use client\n}\n')),(0,r.kt)("p",null,"The following are valid addresses:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"3000")," (interpreted as ",(0,r.kt)("inlineCode",{parentName:"li"},"127.0.0.1:3000"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"127.0.0.1:3000")," (interpreted as ",(0,r.kt)("inlineCode",{parentName:"li"},"127.0.0.1:3000"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"127.0.0.1")," (interpreted as ",(0,r.kt)("inlineCode",{parentName:"li"},"127.0.0.1:3001"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"3001")," is the default port)")),(0,r.kt)("h2",{id:"creating-accounts"},"Creating Accounts"),(0,r.kt)("p",null,"See details for account fields in the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.tigerbeetle.com/reference/account"},"Accounts\nreference"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"AccountBatch accounts = new AccountBatch(1);\naccounts.add();\naccounts.setId(UInt128.id()); // TigerBeetle time-based ID.\naccounts.setUserData128(0, 0);\naccounts.setUserData64(0);\naccounts.setUserData32(0);\naccounts.setLedger(1);\naccounts.setCode(718);\naccounts.setFlags(AccountFlags.NONE);\naccounts.setTimestamp(0);\n\nCreateAccountResultBatch accountErrors = client.createAccounts(accounts);\n// Error handling omitted.\n")),(0,r.kt)("p",null,"See details for the recommended ID scheme in\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.tigerbeetle.com/coding/data-modeling#tigerbeetle-time-based-identifiers-recommended"},"time-based identifiers"),"."),(0,r.kt)("p",null,"The 128-bit fields like ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"user_data_128")," have a few\noverrides to make it easier to integrate. You can either\npass in a long, a pair of longs (least and most\nsignificant bits), or a ",(0,r.kt)("inlineCode",{parentName:"p"},"byte[]"),"."),(0,r.kt)("p",null,"There is also a ",(0,r.kt)("inlineCode",{parentName:"p"},"com.tigerbeetle.UInt128")," helper with static\nmethods for converting 128-bit little-endian unsigned integers\nbetween instances of ",(0,r.kt)("inlineCode",{parentName:"p"},"long"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"java.util.UUID"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"java.math.BigInteger")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"byte[]"),"."),(0,r.kt)("p",null,"The fields for transfer amounts and account balances are also 128-bit,\nbut they are always represented as a ",(0,r.kt)("inlineCode",{parentName:"p"},"java.math.BigInteger"),"."),(0,r.kt)("h3",{id:"account-flags"},"Account Flags"),(0,r.kt)("p",null,"The account flags value is a bitfield. See details for\nthese flags in the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.tigerbeetle.com/reference/account#flags"},"Accounts\nreference"),"."),(0,r.kt)("p",null,"To toggle behavior for an account, combine enum values stored in the\n",(0,r.kt)("inlineCode",{parentName:"p"},"AccountFlags")," object with bitwise-or:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AccountFlags.LINKED")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AccountFlags.DEBITS_MUST_NOT_EXCEED_CREDITS")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AccountFlags.CREDITS_MUST_NOT_EXCEED_CREDITS")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AccountFlags.HISTORY"))),(0,r.kt)("p",null,"For example, to link two accounts where the first account\nadditionally has the ",(0,r.kt)("inlineCode",{parentName:"p"},"debits_must_not_exceed_credits")," constraint:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"AccountBatch accounts = new AccountBatch(2);\n\naccounts.add();\naccounts.setId(100);\naccounts.setLedger(1);\naccounts.setCode(718);\naccounts.setFlags(AccountFlags.LINKED | AccountFlags.DEBITS_MUST_NOT_EXCEED_CREDITS);\n\naccounts.add();\naccounts.setId(101);\naccounts.setLedger(1);\naccounts.setCode(718);\naccounts.setFlags(AccountFlags.HISTORY);\n\nCreateAccountResultBatch accountErrors = client.createAccounts(accounts);\n// Error handling omitted.\n")),(0,r.kt)("h3",{id:"response-and-errors"},"Response and Errors"),(0,r.kt)("p",null,"The response is an empty array if all accounts were\ncreated successfully. If the response is non-empty, each\nobject in the response array contains error information\nfor an account that failed. The error object contains an\nerror code and the index of the account in the request\nbatch."),(0,r.kt)("p",null,"See all error conditions in the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.tigerbeetle.com/reference/requests/create_accounts"},"create_accounts\nreference"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'AccountBatch accounts = new AccountBatch(3);\n\naccounts.add();\naccounts.setId(102);\naccounts.setLedger(1);\naccounts.setCode(718);\naccounts.setFlags(AccountFlags.NONE);\n\naccounts.add();\naccounts.setId(103);\naccounts.setLedger(1);\naccounts.setCode(718);\naccounts.setFlags(AccountFlags.NONE);\n\naccounts.add();\naccounts.setId(104);\naccounts.setLedger(1);\naccounts.setCode(718);\naccounts.setFlags(AccountFlags.NONE);\n\nCreateAccountResultBatch accountErrors = client.createAccounts(accounts);\nwhile (accountErrors.next()) {\n    switch (accountErrors.getResult()) {\n        case Exists:\n            System.err.printf("Batch account at %d already exists.\\n",\n                    accountErrors.getIndex());\n            break;\n\n        default:\n            System.err.printf("Batch account at %d failed to create %s.\\n",\n                    accountErrors.getIndex(), accountErrors.getResult());\n            break;\n    }\n}\n')),(0,r.kt)("h2",{id:"account-lookup"},"Account Lookup"),(0,r.kt)("p",null,"Account lookup is batched, like account creation. Pass\nin all IDs to fetch. The account for each matched ID is returned."),(0,r.kt)("p",null,"If no account matches an ID, no object is returned for\nthat account. So the order of accounts in the response is\nnot necessarily the same as the order of IDs in the\nrequest. You can refer to the ID field in the response to\ndistinguish accounts."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"IdBatch ids = new IdBatch(2);\nids.add(100);\nids.add(101);\n\nAccountBatch accounts = client.lookupAccounts(ids);\n")),(0,r.kt)("h2",{id:"create-transfers"},"Create Transfers"),(0,r.kt)("p",null,"This creates a journal entry between two accounts."),(0,r.kt)("p",null,"See details for transfer fields in the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.tigerbeetle.com/reference/transfer"},"Transfers\nreference"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"TransferBatch transfers = new TransferBatch(1);\n\ntransfers.add();\ntransfers.setId(UInt128.id());\ntransfers.setDebitAccountId(102);\ntransfers.setCreditAccountId(103);\ntransfers.setAmount(10);\ntransfers.setUserData128(0, 0);\ntransfers.setUserData64(0);\ntransfers.setUserData32(0);\ntransfers.setTimeout(0);\ntransfers.setLedger(1);\ntransfers.setCode(1);\ntransfers.setFlags(TransferFlags.NONE);\ntransfers.setTimeout(0);\n\nCreateTransferResultBatch transferErrors = client.createTransfers(transfers);\n// Error handling omitted.\n")),(0,r.kt)("p",null,"See details for the recommended ID scheme in\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.tigerbeetle.com/coding/data-modeling#tigerbeetle-time-based-identifiers-recommended"},"time-based identifiers"),"."),(0,r.kt)("h3",{id:"response-and-errors-1"},"Response and Errors"),(0,r.kt)("p",null,"The response is an empty array if all transfers were created\nsuccessfully. If the response is non-empty, each object in the\nresponse array contains error information for a transfer that\nfailed. The error object contains an error code and the index of the\ntransfer in the request batch."),(0,r.kt)("p",null,"See all error conditions in the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.tigerbeetle.com/reference/requests/create_transfers"},"create_transfers\nreference"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'TransferBatch transfers = new TransferBatch(3);\n\ntransfers.add();\ntransfers.setId(1);\ntransfers.setDebitAccountId(102);\ntransfers.setCreditAccountId(103);\ntransfers.setAmount(10);\ntransfers.setLedger(1);\ntransfers.setCode(1);\n\ntransfers.add();\ntransfers.setId(2);\ntransfers.setDebitAccountId(102);\ntransfers.setCreditAccountId(103);\ntransfers.setAmount(10);\ntransfers.setLedger(1);\ntransfers.setCode(1);\n\ntransfers.add();\ntransfers.setId(3);\ntransfers.setDebitAccountId(102);\ntransfers.setCreditAccountId(103);\ntransfers.setAmount(10);\ntransfers.setLedger(1);\ntransfers.setCode(1);\n\nCreateTransferResultBatch transferErrors = client.createTransfers(transfers);\nwhile (transferErrors.next()) {\n    switch (transferErrors.getResult()) {\n        case ExceedsCredits:\n            System.err.printf("Batch transfer at %d already exists.\\n",\n                    transferErrors.getIndex());\n            break;\n\n        default:\n            System.err.printf("Batch transfer at %d failed to create: %s\\n",\n                    transferErrors.getIndex(), transferErrors.getResult());\n            break;\n    }\n}\n')),(0,r.kt)("h2",{id:"batching"},"Batching"),(0,r.kt)("p",null,"TigerBeetle performance is maximized when you batch\nAPI requests. The client does not do this automatically for\nyou. So, for example, you ",(0,r.kt)("em",{parentName:"p"},"can")," insert 1 million transfers\none at a time like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'ResultSet dataSource = null; /* Loaded from an external source. */;\nwhile(dataSource.next()) {\n    TransferBatch batch = new TransferBatch(1);\n\n    batch.add();\n    batch.setId(dataSource.getBytes("id"));\n    batch.setDebitAccountId(dataSource.getBytes("debit_account_id"));\n    batch.setCreditAccountId(dataSource.getBytes("credit_account_id"));\n    batch.setAmount(dataSource.getBigDecimal("amount").toBigInteger());\n    batch.setLedger(dataSource.getInt("ledger"));\n    batch.setCode(dataSource.getInt("code"));\n\n    CreateTransferResultBatch transferErrors = client.createTransfers(batch);\n    // Error handling omitted.\n}\n')),(0,r.kt)("p",null,"But the insert rate will be a ",(0,r.kt)("em",{parentName:"p"},"fraction")," of\npotential. Instead, ",(0,r.kt)("strong",{parentName:"p"},"always batch what you can"),"."),(0,r.kt)("p",null,"The maximum batch size is set in the TigerBeetle server. The default\nis 8190."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'ResultSet dataSource = null; /* Loaded from an external source. */;\n\nvar BATCH_SIZE = 8190;\nTransferBatch batch = new TransferBatch(BATCH_SIZE);\nwhile(dataSource.next()) {\n    batch.add();\n    batch.setId(dataSource.getBytes("id"));\n    batch.setDebitAccountId(dataSource.getBytes("debit_account_id"));\n    batch.setCreditAccountId(dataSource.getBytes("credit_account_id"));\n    batch.setAmount(dataSource.getBigDecimal("amount").toBigInteger());\n    batch.setLedger(dataSource.getInt("ledger"));\n    batch.setCode(dataSource.getInt("code"));\n\n    if (batch.getLength() == BATCH_SIZE) {\n        CreateTransferResultBatch transferErrors = client.createTransfers(batch);\n        // Error handling omitted.\n\n        // Reset the batch for the next iteration.\n        batch.beforeFirst();\n    }\n}\n\nif (batch.getLength() > 0) {\n    // Send the remaining items.\n    CreateTransferResultBatch transferErrors = client.createTransfers(batch);\n    // Error handling omitted.\n}\n\n')),(0,r.kt)("h3",{id:"queues-and-workers"},"Queues and Workers"),(0,r.kt)("p",null,"If you are making requests to TigerBeetle from workers\npulling jobs from a queue, you can batch requests to\nTigerBeetle by having the worker act on multiple jobs from\nthe queue at once rather than one at a time. i.e. pulling\nmultiple jobs from the queue rather than just one."),(0,r.kt)("h2",{id:"transfer-flags"},"Transfer Flags"),(0,r.kt)("p",null,"The transfer ",(0,r.kt)("inlineCode",{parentName:"p"},"flags")," value is a bitfield. See details for these flags in\nthe ",(0,r.kt)("a",{parentName:"p",href:"https://docs.tigerbeetle.com/reference/transfer#flags"},"Transfers\nreference"),"."),(0,r.kt)("p",null,"To toggle behavior for an account, combine enum values stored in the\n",(0,r.kt)("inlineCode",{parentName:"p"},"TransferFlags")," object with bitwise-or:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TransferFlags.NONE")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TransferFlags.LINKED")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TransferFlags.PENDING")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TransferFlags.POST_PENDING_TRANSFER")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TransferFlags.VOID_PENDING_TRANSFER"))),(0,r.kt)("p",null,"For example, to link ",(0,r.kt)("inlineCode",{parentName:"p"},"transfer0")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"transfer1"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"TransferBatch transfers = new TransferBatch(2);\n\n// First transfer\ntransfers.add();\ntransfers.setId(4);\ntransfers.setDebitAccountId(102);\ntransfers.setCreditAccountId(103);\ntransfers.setAmount(10);\ntransfers.setLedger(1);\ntransfers.setCode(1);\ntransfers.setFlags(TransferFlags.LINKED);\n\ntransfers.add();\ntransfers.setId(5);\ntransfers.setDebitAccountId(102);\ntransfers.setCreditAccountId(103);\ntransfers.setAmount(10);\ntransfers.setLedger(1);\ntransfers.setCode(1);\ntransfers.setFlags(TransferFlags.NONE);\n\nCreateTransferResultBatch transferErrors = client.createTransfers(transfers);\n// Error handling omitted.\n")),(0,r.kt)("h3",{id:"two-phase-transfers"},"Two-Phase Transfers"),(0,r.kt)("p",null,"Two-phase transfers are supported natively by toggling the appropriate\nflag. TigerBeetle will then adjust the ",(0,r.kt)("inlineCode",{parentName:"p"},"credits_pending")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"debits_pending")," fields of the appropriate accounts. A corresponding\npost pending transfer then needs to be sent to post or void the\ntransfer."),(0,r.kt)("h4",{id:"post-a-pending-transfer"},"Post a Pending Transfer"),(0,r.kt)("p",null,"With ",(0,r.kt)("inlineCode",{parentName:"p"},"flags")," set to ",(0,r.kt)("inlineCode",{parentName:"p"},"post_pending_transfer"),",\nTigerBeetle will post the transfer. TigerBeetle will atomically roll\nback the changes to ",(0,r.kt)("inlineCode",{parentName:"p"},"debits_pending")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"credits_pending")," of the\nappropriate accounts and apply them to the ",(0,r.kt)("inlineCode",{parentName:"p"},"debits_posted")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"credits_posted")," balances."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"TransferBatch transfers = new TransferBatch(1);\n\ntransfers.add();\ntransfers.setId(6);\ntransfers.setDebitAccountId(102);\ntransfers.setCreditAccountId(103);\ntransfers.setAmount(10);\ntransfers.setLedger(1);\ntransfers.setCode(1);\ntransfers.setFlags(TransferFlags.PENDING);\n\nCreateTransferResultBatch transferErrors = client.createTransfers(transfers);\n// Error handling omitted.\n\ntransfers = new TransferBatch(1);\n\ntransfers.add();\ntransfers.setId(7);\ntransfers.setAmount(TransferBatch.AMOUNT_MAX);\ntransfers.setPendingId(6);\ntransfers.setFlags(TransferFlags.POST_PENDING_TRANSFER);\n\ntransferErrors = client.createTransfers(transfers);\n// Error handling omitted.\n")),(0,r.kt)("h4",{id:"void-a-pending-transfer"},"Void a Pending Transfer"),(0,r.kt)("p",null,"In contrast, with ",(0,r.kt)("inlineCode",{parentName:"p"},"flags")," set to ",(0,r.kt)("inlineCode",{parentName:"p"},"void_pending_transfer"),",\nTigerBeetle will void the transfer. TigerBeetle will roll\nback the changes to ",(0,r.kt)("inlineCode",{parentName:"p"},"debits_pending")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"credits_pending")," of the\nappropriate accounts and ",(0,r.kt)("strong",{parentName:"p"},"not")," apply them to the ",(0,r.kt)("inlineCode",{parentName:"p"},"debits_posted")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"credits_posted")," balances."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"TransferBatch transfers = new TransferBatch(1);\n\ntransfers.add();\ntransfers.setId(8);\ntransfers.setDebitAccountId(102);\ntransfers.setCreditAccountId(103);\ntransfers.setAmount(10);\ntransfers.setLedger(1);\ntransfers.setCode(1);\ntransfers.setFlags(TransferFlags.PENDING);\n\nCreateTransferResultBatch transferErrors = client.createTransfers(transfers);\n// Error handling omitted.\n\ntransfers = new TransferBatch(1);\n\ntransfers.add();\ntransfers.setId(9);\ntransfers.setAmount(0);\ntransfers.setPendingId(8);\ntransfers.setFlags(TransferFlags.VOID_PENDING_TRANSFER);\n\ntransferErrors = client.createTransfers(transfers);\n// Error handling omitted.\n")),(0,r.kt)("h2",{id:"transfer-lookup"},"Transfer Lookup"),(0,r.kt)("p",null,"NOTE: While transfer lookup exists, it is not a flexible query API. We\nare developing query APIs and there will be new methods for querying\ntransfers in the future."),(0,r.kt)("p",null,"Transfer lookup is batched, like transfer creation. Pass in all ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),"s to\nfetch, and matched transfers are returned."),(0,r.kt)("p",null,"If no transfer matches an ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),", no object is returned for that\ntransfer. So the order of transfers in the response is not necessarily\nthe same as the order of ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),"s in the request. You can refer to the\n",(0,r.kt)("inlineCode",{parentName:"p"},"id")," field in the response to distinguish transfers."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"IdBatch ids = new IdBatch(2);\nids.add(1);\nids.add(2);\n\nTransferBatch transfers = client.lookupTransfers(ids);\n")),(0,r.kt)("h2",{id:"get-account-transfers"},"Get Account Transfers"),(0,r.kt)("p",null,"NOTE: This is a preview API that is subject to breaking changes once we have\na stable querying API."),(0,r.kt)("p",null,"Fetches the transfers involving a given account, allowing basic filter and pagination\ncapabilities."),(0,r.kt)("p",null,"The transfers in the response are sorted by ",(0,r.kt)("inlineCode",{parentName:"p"},"timestamp")," in chronological or\nreverse-chronological order."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"AccountFilter filter = new AccountFilter();\nfilter.setAccountId(2);\nfilter.setUserData128(0); // No filter by UserData.\nfilter.setUserData64(0);\nfilter.setUserData32(0);\nfilter.setCode(0); // No filter by Code.\nfilter.setTimestampMin(0); // No filter by Timestamp.\nfilter.setTimestampMax(0); // No filter by Timestamp.\nfilter.setLimit(10); // Limit to ten transfers at most.\nfilter.setDebits(true); // Include transfer from the debit side.\nfilter.setCredits(true); // Include transfer from the credit side.\nfilter.setReversed(true); // Sort by timestamp in reverse-chronological order.\n\nTransferBatch transfers = client.getAccountTransfers(filter);\n")),(0,r.kt)("h2",{id:"get-account-balances"},"Get Account Balances"),(0,r.kt)("p",null,"NOTE: This is a preview API that is subject to breaking changes once we have\na stable querying API."),(0,r.kt)("p",null,"Fetches the point-in-time balances of a given account, allowing basic filter and\npagination capabilities."),(0,r.kt)("p",null,"Only accounts created with the flag\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.tigerbeetle.com/reference/account#flagshistory"},(0,r.kt)("inlineCode",{parentName:"a"},"history"))," set retain\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.tigerbeetle.com/reference/requests/get_account_balances"},"historical balances"),"."),(0,r.kt)("p",null,"The balances in the response are sorted by ",(0,r.kt)("inlineCode",{parentName:"p"},"timestamp")," in chronological or\nreverse-chronological order."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"AccountFilter filter = new AccountFilter();\nfilter.setAccountId(2);\nfilter.setUserData128(0); // No filter by UserData.\nfilter.setUserData64(0);\nfilter.setUserData32(0);\nfilter.setCode(0); // No filter by Code.\nfilter.setTimestampMin(0); // No filter by Timestamp.\nfilter.setTimestampMax(0); // No filter by Timestamp.\nfilter.setLimit(10); // Limit to ten balances at most.\nfilter.setDebits(true); // Include transfer from the debit side.\nfilter.setCredits(true); // Include transfer from the credit side.\nfilter.setReversed(true); // Sort by timestamp in reverse-chronological order.\n\nAccountBalanceBatch account_balances = client.getAccountBalances(filter);\n")),(0,r.kt)("h2",{id:"query-accounts"},"Query Accounts"),(0,r.kt)("p",null,"NOTE: This is a preview API that is subject to breaking changes once we have\na stable querying API."),(0,r.kt)("p",null,"Query accounts by the intersection of some fields and by timestamp range."),(0,r.kt)("p",null,"The accounts in the response are sorted by ",(0,r.kt)("inlineCode",{parentName:"p"},"timestamp")," in chronological or\nreverse-chronological order."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"QueryFilter filter = new QueryFilter();\nfilter.setUserData128(1000); // Filter by UserData.\nfilter.setUserData64(100);\nfilter.setUserData32(10);\nfilter.setCode(1); // Filter by Code.\nfilter.setLedger(0); // No filter by Ledger.\nfilter.setTimestampMin(0); // No filter by Timestamp.\nfilter.setTimestampMax(0); // No filter by Timestamp.\nfilter.setLimit(10); // Limit to ten balances at most.\nfilter.setReversed(true); // Sort by timestamp in reverse-chronological order.\n\nAccountBatch accounts = client.queryAccounts(filter);\n")),(0,r.kt)("h2",{id:"query-transfers"},"Query Transfers"),(0,r.kt)("p",null,"NOTE: This is a preview API that is subject to breaking changes once we have\na stable querying API."),(0,r.kt)("p",null,"Query transfers by the intersection of some fields and by timestamp range."),(0,r.kt)("p",null,"The transfers in the response are sorted by ",(0,r.kt)("inlineCode",{parentName:"p"},"timestamp")," in chronological or\nreverse-chronological order."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"QueryFilter filter = new QueryFilter();\nfilter.setUserData128(1000); // Filter by UserData.\nfilter.setUserData64(100);\nfilter.setUserData32(10);\nfilter.setCode(1); // Filter by Code.\nfilter.setLedger(0); // No filter by Ledger.\nfilter.setTimestampMin(0); // No filter by Timestamp.\nfilter.setTimestampMax(0); // No filter by Timestamp.\nfilter.setLimit(10); // Limit to ten balances at most.\nfilter.setReversed(true); // Sort by timestamp in reverse-chronological order.\n\nTransferBatch transfers = client.queryTransfers(filter);\n")),(0,r.kt)("h2",{id:"linked-events"},"Linked Events"),(0,r.kt)("p",null,"When the ",(0,r.kt)("inlineCode",{parentName:"p"},"linked")," flag is specified for an account when creating accounts or\na transfer when creating transfers, it links that event with the next event in the\nbatch, to create a chain of events, of arbitrary length, which all\nsucceed or fail together. The tail of a chain is denoted by the first\nevent without this flag. The last event in a batch may therefore never\nhave the ",(0,r.kt)("inlineCode",{parentName:"p"},"linked")," flag set as this would leave a chain\nopen-ended. Multiple chains or individual events may coexist within a\nbatch to succeed or fail independently."),(0,r.kt)("p",null,"Events within a chain are executed within order, or are rolled back on\nerror, so that the effect of each event in the chain is visible to the\nnext, and so that the chain is either visible or invisible as a unit\nto subsequent events after the chain. The event that was the first to\nbreak the chain will have a unique error result. Other events in the\nchain will have their error result set to ",(0,r.kt)("inlineCode",{parentName:"p"},"linked_event_failed"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"TransferBatch transfers = new TransferBatch(10);\n\n// An individual transfer (successful):\ntransfers.add();\ntransfers.setId(1);\n// ... rest of transfer ...\ntransfers.setFlags(TransferFlags.NONE);\n\n// A chain of 4 transfers (the last transfer in the chain closes the chain with\n// linked=false):\ntransfers.add();\ntransfers.setId(2); // Commit/rollback.\n// ... rest of transfer ...\ntransfers.setFlags(TransferFlags.LINKED);\ntransfers.add();\ntransfers.setId(3); // Commit/rollback.\n// ... rest of transfer ...\ntransfers.setFlags(TransferFlags.LINKED);\ntransfers.add();\ntransfers.setId(2); // Fail with exists\n// ... rest of transfer ...\ntransfers.setFlags(TransferFlags.LINKED);\ntransfers.add();\ntransfers.setId(4); // Fail without committing\n// ... rest of transfer ...\ntransfers.setFlags(TransferFlags.NONE);\n\n// An individual transfer (successful):\n// This should not see any effect from the failed chain above.\ntransfers.add();\ntransfers.setId(2);\n// ... rest of transfer ...\ntransfers.setFlags(TransferFlags.NONE);\n\n// A chain of 2 transfers (the first transfer fails the chain):\ntransfers.add();\ntransfers.setId(2);\n// ... rest of transfer ...\ntransfers.setFlags(TransferFlags.LINKED);\ntransfers.add();\ntransfers.setId(3);\n// ... rest of transfer ...\ntransfers.setFlags(TransferFlags.NONE);\n// A chain of 2 transfers (successful):\ntransfers.add();\ntransfers.setId(3);\n// ... rest of transfer ...\ntransfers.setFlags(TransferFlags.LINKED);\ntransfers.add();\ntransfers.setId(4);\n// ... rest of transfer ...\ntransfers.setFlags(TransferFlags.NONE);\n\nCreateTransferResultBatch transferErrors = client.createTransfers(transfers);\n// Error handling omitted.\n")),(0,r.kt)("h2",{id:"imported-events"},"Imported Events"),(0,r.kt)("p",null,"When the ",(0,r.kt)("inlineCode",{parentName:"p"},"imported")," flag is specified for an account when creating accounts or\na transfer when creating transfers, it allows importing historical events with\na user-defined timestamp."),(0,r.kt)("p",null,"The entire batch of events must be set with the flag ",(0,r.kt)("inlineCode",{parentName:"p"},"imported"),"."),(0,r.kt)("p",null,"It's recommended to submit the whole batch as a ",(0,r.kt)("inlineCode",{parentName:"p"},"linked")," chain of events, ensuring that\nif any event fails, none of them are committed, preserving the last timestamp unchanged.\nThis approach gives the application a chance to correct failed imported events, re-submitting\nthe batch again with the same user-defined timestamps."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// External source of time\nlong historicalTimestamp = 0L;\nResultSet historicalAccounts = null; // Loaded from an external source;\nResultSet historicalTransfers = null ; // Loaded from an external source.\n\nvar BATCH_SIZE = 8190;\n\n// First, load and import all accounts with their timestamps from the historical source.\nAccountBatch accounts = new AccountBatch(BATCH_SIZE);\nwhile (historicalAccounts.next()) {\n    // Set a unique and strictly increasing timestamp.\n    historicalTimestamp += 1;\n\n    accounts.add();\n    accounts.setId(historicalAccounts.getBytes("id"));\n    accounts.setLedger(historicalAccounts.getInt("ledger"));\n    accounts.setCode(historicalAccounts.getInt("code"));\n    accounts.setTimestamp(historicalTimestamp);\n\n    // Set the account as `imported`.\n    // To ensure atomicity, the entire batch (except the last event in the chain)\n    // must be `linked`.\n    if (accounts.getLength() < BATCH_SIZE) {\n        accounts.setFlags(AccountFlags.IMPORTED | AccountFlags.LINKED);\n    } else {\n        accounts.setFlags(AccountFlags.IMPORTED);\n\n        CreateAccountResultBatch accountsErrors = client.createAccounts(accounts);\n        // Error handling omitted.\n\n        // Reset the batch for the next iteration.\n        accounts.beforeFirst();\n    }\n}\n\nif (accounts.getLength() > 0) {\n    // Send the remaining items.\n    CreateAccountResultBatch accountsErrors = client.createAccounts(accounts);\n    // Error handling omitted.\n}\n\n// Then, load and import all transfers with their timestamps from the historical source.\nTransferBatch transfers = new TransferBatch(BATCH_SIZE);\nwhile (historicalTransfers.next()) {\n    // Set a unique and strictly increasing timestamp.\n    historicalTimestamp += 1;\n\n    transfers.add();\n    transfers.setId(historicalTransfers.getBytes("id"));\n    transfers.setDebitAccountId(historicalTransfers.getBytes("debit_account_id"));\n    transfers.setCreditAccountId(historicalTransfers.getBytes("credit_account_id"));\n    transfers.setAmount(historicalTransfers.getBigDecimal("amount").toBigInteger());\n    transfers.setLedger(historicalTransfers.getInt("ledger"));\n    transfers.setCode(historicalTransfers.getInt("code"));\n    transfers.setTimestamp(historicalTimestamp);\n\n    // Set the transfer as `imported`.\n    // To ensure atomicity, the entire batch (except the last event in the chain)\n    // must be `linked`.\n    if (transfers.getLength() < BATCH_SIZE) {\n        transfers.setFlags(TransferFlags.IMPORTED | TransferFlags.LINKED);\n    } else {\n        transfers.setFlags(TransferFlags.IMPORTED);\n\n        CreateTransferResultBatch transferErrors = client.createTransfers(transfers);\n        // Error handling omitted.\n\n        // Reset the batch for the next iteration.\n        transfers.beforeFirst();\n    }\n}\n\nif (transfers.getLength() > 0) {\n    // Send the remaining items.\n    CreateTransferResultBatch transferErrors = client.createTransfers(transfers);\n    // Error handling omitted.\n}\n\n// Since it is a linked chain, in case of any error the entire batch is rolled back and can be retried\n// with the same historical timestamps without regressing the cluster timestamp.\n')))}f.isMDXComponent=!0}}]);